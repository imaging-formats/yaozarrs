{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>yaozarrs!!</p> Yet Another Ome-ZARR Schema! <p>Pydantic models for the OME-Zarr specification.</p> <p>Warning</p> <p>This is an experimental project.  Playing with a bottom-up design, starting with the OME-Zarr specification for JSON documents expressed as models.  </p> <p>See first: </p> <p>ome-zarr-models-py,  which is more of a top-down design, starting from a <code>zarr.Group</code>, and  validating the metadata within.  It has the community buy in and you should probably start there.</p>"},{"location":"reference/yaozarrs/","title":"yaozarrs","text":""},{"location":"reference/yaozarrs/#yaozarrs","title":"yaozarrs","text":"<p>Yet another ome-zarr model.</p> <p>Modules:</p> <ul> <li> <code>v04</code>           \u2013            <p>v04 ome-zarr model.</p> </li> <li> <code>v05</code>           \u2013            <p>v05 ome-zarr model.</p> </li> <li> <code>write</code>           \u2013            <p>Write utilities for yaozarrs.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DimSpec</code>           \u2013            <p>Specification for a single dimension of an OME-Zarr image.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>from_uri</code>             \u2013              <p>Load and validate any OME-Zarr group from a URI or local path.</p> </li> <li> <code>open_group</code>             \u2013              <p>Open a zarr v2/v3 group from a URI.</p> </li> <li> <code>validate_ome_json</code>             \u2013              <p>Validate any valid ome-zarr JSON data.</p> </li> <li> <code>validate_ome_object</code>             \u2013              <p>Validate any ome-zarr document or node as a python object.</p> </li> <li> <code>validate_zarr_store</code>             \u2013              <p>Validate an OME-Zarr v0.5 storage structure.</p> </li> </ul>"},{"location":"reference/yaozarrs/#yaozarrs.DimSpec","title":"DimSpec","text":"<p>               Bases: <code>_BaseModel</code></p> <p>Specification for a single dimension of an OME-Zarr image.</p> <p>Important</p> <p>This is a convenience class and is not part of the OME-Zarr specification.</p> <p>There are some places in the OME Zarr spec where information about a given axis must be entered in multiple different places (e.g., <code>Multiscale.axes</code> must agree with <code>Multiscale.datasets.CoordinateTransformation</code>, etc). <code>DimSpec</code> is a convenience class that encapsulates all the relevant information about a single dimension in one place, and may be used in specialized constructors (e.g. <code>v05.Multiscale.from_dims</code>)</p> <p>Examples:</p> <p>5D timelapse with channels:</p> <pre><code>&gt;&gt;&gt; from yaozarrs import DimSpec, v05\n&gt;&gt;&gt; dims = [\n...     DimSpec(name=\"t\", size=100, scale=1.0, unit=\"second\"),\n...     DimSpec(name=\"c\", size=3),\n...     DimSpec(name=\"z\", size=50, scale=2.0, unit=\"micrometer\"),\n...     DimSpec(name=\"y\", size=512, scale=0.5, unit=\"micrometer\"),\n...     DimSpec(name=\"x\", size=512, scale=0.5, unit=\"micrometer\"),\n... ]\n&gt;&gt;&gt; multiscale = v05.Multiscale.from_dims(dims, name=\"my_image\", n_levels=3)\n</code></pre> <p>Methods:</p> <ul> <li> <code>infer_scale_factor</code>             \u2013              <p>Infer the scale factor for downsampling based on dimension type.</p> </li> <li> <code>infer_type</code>             \u2013              <p>Infer the axis type from the dimension name.</p> </li> </ul>"},{"location":"reference/yaozarrs/#yaozarrs.DimSpec.infer_scale_factor","title":"infer_scale_factor","text":"<pre><code>infer_scale_factor() -&gt; float\n</code></pre> <p>Infer the scale factor for downsampling based on dimension type.</p> Source code in <code>src/yaozarrs/_dim_spec.py</code> <pre><code>def infer_scale_factor(self) -&gt; float:\n    \"\"\"Infer the scale factor for downsampling based on dimension type.\"\"\"\n    if self.scale_factor is not None:\n        return self.scale_factor\n    return 2.0 if self.infer_type() == \"space\" else 1.0\n</code></pre>"},{"location":"reference/yaozarrs/#yaozarrs.DimSpec.infer_type","title":"infer_type","text":"<pre><code>infer_type() -&gt; str | None\n</code></pre> <p>Infer the axis type from the dimension name.</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>The inferred type: 'space' for x/y/z, 'time' for t, 'channel' for c, or the explicitly set type if provided.</p> </li> </ul> Source code in <code>src/yaozarrs/_dim_spec.py</code> <pre><code>def infer_type(self) -&gt; str | None:\n    \"\"\"Infer the axis type from the dimension name.\n\n    Returns\n    -------\n    str | None\n        The inferred type: 'space' for x/y/z, 'time' for t, 'channel' for c,\n        or the explicitly set type if provided.\n    \"\"\"\n    if self.type is not None:\n        return self.type\n    name_lower = self.name.lower()\n    if name_lower in (\"x\", \"y\", \"z\"):\n        return \"space\"\n    if name_lower in {\"t\", \"time\"}:\n        return \"time\"\n    if name_lower in {\"c\", \"channel\"}:\n        return \"channel\"\n    return None\n</code></pre>"},{"location":"reference/yaozarrs/#yaozarrs.from_uri","title":"from_uri","text":"<pre><code>from_uri(uri: str | PathLike, cls: type[T]) -&gt; T\n</code></pre><pre><code>from_uri(uri: str | PathLike) -&gt; AnyOMEGroup\n</code></pre> <pre><code>from_uri(\n    uri: str | PathLike, cls: type[T] | Any = None\n) -&gt; T | AnyOMEGroup\n</code></pre> <p>Load and validate any OME-Zarr group from a URI or local path.</p> <p>This function will attempt to load the OME-Zarr group metadata from the given URI or local path. It supports both v0.4 and v0.5 of the OME-Zarr specification. The URI should be a path to a zarr group (directory or URL) with valid ome-zarr metadata, or a path directly to the metadata JSON file itself (e.g. zarr.json or .zattrs).</p> <p>This requires that you have installed yaozarrs with the <code>io</code> extra, e.g. <code>pip install yaozarrs[io]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AnyOME</code>           \u2013            <p>An instance of <code>v05.OMEZarrGroupJSON</code>, <code>v04.OMEZarrGroupJSON</code>, or another valid OME-Zarr node type, depending on the object detected.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the URI does not point to a valid OME-Zarr group.</p> </li> <li> <code>ValidationError</code>             \u2013            <p>If the loaded metadata is not valid according to the OME-Zarr specification.</p> </li> </ul> Source code in <code>src/yaozarrs/_validate.py</code> <pre><code>def from_uri(uri: str | os.PathLike, cls: type[T] | Any = None) -&gt; T | AnyOMEGroup:\n    \"\"\"Load and validate any OME-Zarr group from a URI or local path.\n\n    This function will attempt to load the OME-Zarr group metadata from the given\n    URI or local path. It supports both v0.4 and v0.5 of the OME-Zarr specification.\n    The URI should be a path to a zarr group (directory or URL) with valid ome-zarr\n    metadata, or a path directly to the metadata JSON file itself (e.g. zarr.json or\n    .zattrs).\n\n    This requires that you have installed yaozarrs with the `io` extra, e.g.\n    `pip install yaozarrs[io]`.\n\n    Parameters\n    ----------\n    uri : str | os.PathLike\n        The URI or local path to the OME-Zarr group. This can be a file path,\n        a directory path, or a URL.\n    cls : type[T]\n        The class to validate against. Must be a subclass of `BaseModel`.\n\n    Returns\n    -------\n    AnyOME\n        An instance of `v05.OMEZarrGroupJSON`, `v04.OMEZarrGroupJSON`, or another\n        valid OME-Zarr node type, depending on the object detected.\n\n    Raises\n    ------\n    FileNotFoundError\n        If the URI does not point to a valid OME-Zarr group.\n    pydantic.ValidationError\n        If the loaded metadata is not valid according to the OME-Zarr specification.\n    \"\"\"\n    from ._io import read_json_from_uri\n\n    json_content, uri_str = read_json_from_uri(uri)\n    obj = validate_ome_json(json_content, cls or AnyOMEGroup)  # type: ignore\n    obj.uri = uri_str\n    return obj\n</code></pre>"},{"location":"reference/yaozarrs/#yaozarrs.from_uri(uri)","title":"<code>uri</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>The URI or local path to the OME-Zarr group. This can be a file path, a directory path, or a URL.</p>"},{"location":"reference/yaozarrs/#yaozarrs.from_uri(cls)","title":"<code>cls</code>","text":"(<code>type[T]</code>, default:                   <code>None</code> )           \u2013            <p>The class to validate against. Must be a subclass of <code>BaseModel</code>.</p>"},{"location":"reference/yaozarrs/#yaozarrs.open_group","title":"open_group","text":"<pre><code>open_group(uri: str | PathLike | Any) -&gt; ZarrGroup\n</code></pre> <p>Open a zarr v2/v3 group from a URI.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ZarrGroup</code>           \u2013            <p>The opened zarr group with caching enabled.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If no zarr metadata is found at the specified URI.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the metadata is invalid or inconsistent, or if the root node is not a group.</p> </li> </ul> Source code in <code>src/yaozarrs/_zarr.py</code> <pre><code>def open_group(uri: str | os.PathLike | Any) -&gt; ZarrGroup:\n    \"\"\"Open a zarr v2/v3 group from a URI.\n\n    Parameters\n    ----------\n    uri : str | os.PathLike\n        The URI of the zarr store (e.g., \"https://...\", \"s3://...\", \"/path/to/file\"),\n        or a zarr-python Group.\n\n    Returns\n    -------\n    ZarrGroup\n        The opened zarr group with caching enabled.\n\n    Raises\n    ------\n    FileNotFoundError\n        If no zarr metadata is found at the specified URI.\n    ValueError\n        If the metadata is invalid or inconsistent, or if the root node is not a group.\n    \"\"\"\n    try:\n        from fsspec import FSMap, get_mapper\n    except ImportError as e:\n        raise ImportError(\n            \"fsspec package is required for open_group().  \"\n            \"Please install with `pip install yaozarrs[io]` or \"\n            \"`pip install fsspec`.\"\n        ) from e\n\n    if isinstance(uri, (str, os.PathLike)):\n        uri = os.path.expanduser(os.fspath(uri))\n    elif isinstance(uri, ZarrGroup):\n        return uri\n    elif hasattr(uri, \"store\"):\n        # Handle both zarr v2 and v3 Group objects\n        # v3: str(group.store) returns a URI like \"file:///path\"\n        # v2: group.store.path returns the directory path\n        if hasattr(uri.store, \"path\"):\n            # Zarr v2: DirectoryStore has .path attribute\n            uri = uri.store.path\n        else:\n            # Zarr v3: LocalStore's __str__ returns URI\n            uri = str(uri.store)\n    else:  # pragma: no cover\n        raise TypeError(\n            \"uri must be a string, os.PathLike, or have a 'store' attribute\"\n        )\n\n    mapper = get_mapper(uri)  # type: ignore\n\n    if not isinstance(mapper, FSMap):  # pragma: no cover\n        raise TypeError(f\"Expected FSMap from get_mapper, got {type(mapper)}\")\n\n    # Wrap in caching layer for metadata-level caching\n    cached_mapper = _CachedMapper(mapper)\n    node = ZarrNode(cached_mapper)\n\n    if node._metadata.node_type != \"group\":\n        raise ValueError(\n            f\"Expected root node to be 'group', got '{node._metadata.node_type}'\"\n        )\n    return ZarrGroup(cached_mapper, node._path, node._metadata)\n</code></pre>"},{"location":"reference/yaozarrs/#yaozarrs.open_group(uri)","title":"<code>uri</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>The URI of the zarr store (e.g., \"https://...\", \"s3://...\", \"/path/to/file\"), or a zarr-python Group.</p>"},{"location":"reference/yaozarrs/#yaozarrs.validate_ome_json","title":"validate_ome_json","text":"<pre><code>validate_ome_json(\n    data: str | bytes | bytearray, cls: type[T]\n) -&gt; T\n</code></pre><pre><code>validate_ome_json(data: str | bytes | bytearray) -&gt; AnyOME\n</code></pre> <pre><code>validate_ome_json(\n    data: str | bytes | bytearray, cls: type[T] | Any = None\n) -&gt; T | AnyOME\n</code></pre> <p>Validate any valid ome-zarr JSON data.</p> <p>By default, this will validate <code>data</code> against all known OME JSON documents. This includes ome-zarr group documents for v04 (found at .zattrs in the zarr group) and v05 (found at zarr.json in the zarr group).  For v05 objects, it also detects data that would valid as the value of the <code>data[\"attributes\"][\"ome\"]</code> key inside a v05 zarr.json document.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValidationError</code>             \u2013            <p>If the validation fails.</p> </li> </ul> Source code in <code>src/yaozarrs/_validate.py</code> <pre><code>def validate_ome_json(\n    data: str | bytes | bytearray, cls: type[T] | Any = None\n) -&gt; T | AnyOME:\n    \"\"\"Validate any valid ome-zarr JSON data.\n\n    By default, this will validate `data` against all known OME JSON documents.\n    This includes ome-zarr group documents for v04 (found at .zattrs in the zarr group)\n    and v05 (found at zarr.json in the zarr group).  For v05 objects, it also detects\n    data that would valid as the value of the `data[\"attributes\"][\"ome\"]` key inside\n    a v05 zarr.json document.\n\n    Parameters\n    ----------\n    data : str | bytes | bytearray\n        The OMENode instance to validate.\n    cls : type[T]\n        The class to validate against. Must be a subclass of `BaseModel`.\n        If not provided, defaults to `OMENode`, meaning any valid OME node object\n\n    Raises\n    ------\n    pydantic.ValidationError\n        If the validation fails.\n    \"\"\"\n    adapter = TypeAdapter[T](cls or AnyOME)\n    return adapter.validate_json(data)\n</code></pre>"},{"location":"reference/yaozarrs/#yaozarrs.validate_ome_json(data)","title":"<code>data</code>","text":"(<code>str | bytes | bytearray</code>)           \u2013            <p>The OMENode instance to validate.</p>"},{"location":"reference/yaozarrs/#yaozarrs.validate_ome_json(cls)","title":"<code>cls</code>","text":"(<code>type[T]</code>, default:                   <code>None</code> )           \u2013            <p>The class to validate against. Must be a subclass of <code>BaseModel</code>. If not provided, defaults to <code>OMENode</code>, meaning any valid OME node object</p>"},{"location":"reference/yaozarrs/#yaozarrs.validate_ome_object","title":"validate_ome_object","text":"<pre><code>validate_ome_object(node: Any, cls: type[T]) -&gt; T\n</code></pre><pre><code>validate_ome_object(node: Any) -&gt; AnyOME\n</code></pre> <pre><code>validate_ome_object(\n    node: Any, cls: type[T] | Any = None\n) -&gt; T | AnyOME\n</code></pre> <p>Validate any ome-zarr document or node as a python object.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValidationError</code>             \u2013            <p>If the validation fails.</p> </li> </ul> Source code in <code>src/yaozarrs/_validate.py</code> <pre><code>def validate_ome_object(node: Any, cls: type[T] | Any = None) -&gt; T | AnyOME:\n    \"\"\"Validate any ome-zarr document or node as a python object.\n\n    Parameters\n    ----------\n    node : OMENode\n        The OMENode instance to validate.\n    cls : type[T]\n        The class to validate against. Must be a subclass of `BaseModel`.\n        If not provided, defaults to `OMENode`, meaning any valid OME node object\n\n    Raises\n    ------\n    pydantic.ValidationError\n        If the validation fails.\n    \"\"\"\n    adapter = TypeAdapter[T](cls or AnyOME)\n    return adapter.validate_python(node)\n</code></pre>"},{"location":"reference/yaozarrs/#yaozarrs.validate_ome_object(node)","title":"<code>node</code>","text":"(<code>OMENode</code>)           \u2013            <p>The OMENode instance to validate.</p>"},{"location":"reference/yaozarrs/#yaozarrs.validate_ome_object(cls)","title":"<code>cls</code>","text":"(<code>type[T]</code>, default:                   <code>None</code> )           \u2013            <p>The class to validate against. Must be a subclass of <code>BaseModel</code>. If not provided, defaults to <code>OMENode</code>, meaning any valid OME node object</p>"},{"location":"reference/yaozarrs/#yaozarrs.validate_zarr_store","title":"validate_zarr_store","text":"<pre><code>validate_zarr_store(\n    obj: ZarrGroup | str | Path | Any,\n) -&gt; None\n</code></pre> <p>Validate an OME-Zarr v0.5 storage structure.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>StorageValidationError</code>             \u2013            <p>If the storage structure is invalid.</p> </li> </ul> Source code in <code>src/yaozarrs/_storage.py</code> <pre><code>def validate_zarr_store(obj: ZarrGroup | str | Path | Any) -&gt; None:\n    \"\"\"Validate an OME-Zarr v0.5 storage structure.\n\n    Parameters\n    ----------\n    obj : OMEZarrGroupJSON | ZarrGroup | str | Path | Any\n        The zarr store to validate. Can be a URI string, a Path, a parsed\n        OMEZarrGroupJSON object, a ZarrGroup instance, or a zarr.Group object\n        (for backwards compatibility).\n\n    Raises\n    ------\n    StorageValidationError\n        If the storage structure is invalid.\n    \"\"\"\n    zarr_group = open_group(obj)\n    ome_version = zarr_group.ome_version()\n    if ome_version == \"0.5\":\n        from yaozarrs.v05._storage import StorageValidatorV05\n\n        # Validate the storage structure using the visitor pattern\n        result = StorageValidatorV05.validate_group(zarr_group)\n    else:\n        raise NotImplementedError(\n            f\"Structural validation for OME-Zarr version {ome_version} is \"\n            \"not implemented.\"\n        )\n\n    # Raise error if any validation issues found\n    if not result.is_valid:\n        raise StorageValidationError(result.errors)\n</code></pre>"},{"location":"reference/yaozarrs/#yaozarrs.validate_zarr_store(obj)","title":"<code>obj</code>","text":"(<code>OMEZarrGroupJSON | ZarrGroup | str | Path | Any</code>)           \u2013            <p>The zarr store to validate. Can be a URI string, a Path, a parsed OMEZarrGroupJSON object, a ZarrGroup instance, or a zarr.Group object (for backwards compatibility).</p>"},{"location":"reference/yaozarrs/v04/","title":"v04","text":""},{"location":"reference/yaozarrs/v04/#yaozarrs.v04","title":"yaozarrs.v04","text":"<p>v04 ome-zarr model.</p> <p>https://ngff.openmicroscopy.org/0.4</p> <p>https://github.com/ome/ngff/tree/7ac3430c74a66e5bcf53e41c429143172d68c0a4</p> <p>Classes:</p> <ul> <li> <code>LabelImage</code>           \u2013            <p>Model for individual label images with multiscales + image-label metadata.</p> </li> <li> <code>Multiscale</code>           \u2013            <p>A multiscale representation of an image.</p> </li> <li> <code>Omero</code>           \u2013            <p>A very rough/incomplete model of ImgData.</p> </li> <li> <code>PlateWell</code>           \u2013            <p>Individual well in a plate.</p> </li> <li> <code>Series</code>           \u2013            <p>Model for the ome group that contains OME-XML metadata.</p> </li> <li> <code>Well</code>           \u2013            <p>A well at the top-level of an ome-zarr file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>OMEZarrGroupJSON</code>               (<code>TypeAlias</code>)           \u2013            <p>A .zattrs document found in any ome-zarr group.</p> </li> </ul>"},{"location":"reference/yaozarrs/v04/#yaozarrs.v04.OMEZarrGroupJSON","title":"OMEZarrGroupJSON  <code>module-attribute</code>","text":"<pre><code>OMEZarrGroupJSON: TypeAlias = Annotated[\n    Annotated[LabelImage, Tag(\"label-image\")]\n    | Annotated[Image, Tag(\"image\")]\n    | Annotated[Plate, Tag(\"plate\")]\n    | Annotated[Bf2Raw, Tag(\"bf2raw\")]\n    | Annotated[Well, Tag(\"well\")]\n    | Annotated[LabelsGroup, Tag(\"labels-group\")]\n    | Annotated[Series, Tag(\"series\")],\n    Discriminator(_discriminate_ome_v04_metadata),\n]\n</code></pre> <p>A .zattrs document found in any ome-zarr group.</p> <p>OME-ZARR v0.4 uses zarr format version 2: https://zarr-specs.readthedocs.io/en/latest/v2/v2.0.html</p> <p>...where the node-type is defined by the presence of a .zgroup or .zarray file. Either node type may also contain a .zattrs file, and that's where the OME metadata lives, without any top-level key.</p>"},{"location":"reference/yaozarrs/v04/#yaozarrs.v04.LabelImage","title":"LabelImage","text":"<p>               Bases: <code>Image</code></p> <p>Model for individual label images with multiscales + image-label metadata.</p>"},{"location":"reference/yaozarrs/v04/#yaozarrs.v04.Multiscale","title":"Multiscale","text":"<p>               Bases: <code>_BaseModel</code></p> <p>A multiscale representation of an image.</p> <p>Methods:</p> <ul> <li> <code>from_dims</code>             \u2013              <p>Convenience constructor: Create Multiscale from a sequence of DimSpec.</p> </li> </ul>"},{"location":"reference/yaozarrs/v04/#yaozarrs.v04.Multiscale.from_dims","title":"from_dims  <code>classmethod</code>","text":"<pre><code>from_dims(\n    dims: Sequence[DimSpec],\n    name: str | None = None,\n    n_levels: int = 1,\n) -&gt; Self\n</code></pre> <p>Convenience constructor: Create Multiscale from a sequence of DimSpec.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Multiscale</code>           \u2013            <p>A fully configured Multiscale model.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from yaozarrs import DimSpec, v04\n&gt;&gt;&gt; dims = [\n...     DimSpec(name=\"t\", size=512, unit=\"second\"),\n...     DimSpec(\n...         name=\"z\", size=50, scale=2.0, unit=\"micrometer\", scale_factor=1.0\n...     ),\n...     DimSpec(name=\"y\", size=512, scale=0.5, unit=\"micrometer\"),\n...     DimSpec(name=\"x\", size=512, scale=0.5, unit=\"micrometer\"),\n... ]\n&gt;&gt;&gt; v04.Multiscale.from_dims(dims, name=\"my_multiscale\", n_levels=3)\n</code></pre> Source code in <code>src/yaozarrs/v04/_image.py</code> <pre><code>@classmethod\ndef from_dims(\n    cls,\n    dims: Sequence[DimSpec],\n    name: str | None = None,\n    n_levels: int = 1,\n) -&gt; Self:\n    \"\"\"Convenience constructor: Create Multiscale from a sequence of DimSpec.\n\n    Parameters\n    ----------\n    dims : Sequence[DimSpec]\n        A sequence of dimension specifications defining the image dimensions.\n        Must follow OME-Zarr axis ordering: `[time,] [channel,] space...`\n    name : str | None, optional\n        Name for the multiscale. Default is None.\n    n_levels : int, optional\n        Number of resolution levels in the pyramid. Default is 1.\n\n    Returns\n    -------\n    Multiscale\n        A fully configured Multiscale model.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from yaozarrs import DimSpec, v04\n    &gt;&gt;&gt; dims = [\n    ...     DimSpec(name=\"t\", size=512, unit=\"second\"),\n    ...     DimSpec(\n    ...         name=\"z\", size=50, scale=2.0, unit=\"micrometer\", scale_factor=1.0\n    ...     ),\n    ...     DimSpec(name=\"y\", size=512, scale=0.5, unit=\"micrometer\"),\n    ...     DimSpec(name=\"x\", size=512, scale=0.5, unit=\"micrometer\"),\n    ... ]\n    &gt;&gt;&gt; v04.Multiscale.from_dims(dims, name=\"my_multiscale\", n_levels=3)\n    \"\"\"\n    from yaozarrs._dim_spec import _axes_datasets\n\n    return cls(name=name, **_axes_datasets(dims, n_levels))  # type: ignore\n</code></pre>"},{"location":"reference/yaozarrs/v04/#yaozarrs.v04.Multiscale.from_dims(dims)","title":"<code>dims</code>","text":"(<code>Sequence[DimSpec]</code>)           \u2013            <p>A sequence of dimension specifications defining the image dimensions. Must follow OME-Zarr axis ordering: <code>[time,] [channel,] space...</code></p>"},{"location":"reference/yaozarrs/v04/#yaozarrs.v04.Multiscale.from_dims(name)","title":"<code>name</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name for the multiscale. Default is None.</p>"},{"location":"reference/yaozarrs/v04/#yaozarrs.v04.Multiscale.from_dims(n_levels)","title":"<code>n_levels</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of resolution levels in the pyramid. Default is 1.</p>"},{"location":"reference/yaozarrs/v04/#yaozarrs.v04.Omero","title":"Omero","text":"<p>               Bases: <code>_BaseModel</code></p> <p>A very rough/incomplete model of ImgData.</p> <p>https://omero.readthedocs.io/en/stable/developers/Web/WebGateway.html#imgdata</p> <p>Extra fields are allowed to accommodate missing fields.</p>"},{"location":"reference/yaozarrs/v04/#yaozarrs.v04.PlateWell","title":"PlateWell","text":"<p>               Bases: <code>_BaseModel</code></p> <p>Individual well in a plate.</p>"},{"location":"reference/yaozarrs/v04/#yaozarrs.v04.Series","title":"Series","text":"<p>               Bases: <code>ZarrGroupModel</code></p> <p>Model for the ome group that contains OME-XML metadata.</p>"},{"location":"reference/yaozarrs/v04/#yaozarrs.v04.Well","title":"Well","text":"<p>               Bases: <code>ZarrGroupModel</code></p> <p>A well at the top-level of an ome-zarr file.</p>"},{"location":"reference/yaozarrs/v05/","title":"v05","text":""},{"location":"reference/yaozarrs/v05/#yaozarrs.v05","title":"yaozarrs.v05","text":"<p>v05 ome-zarr model.</p> <p>https://ngff.openmicroscopy.org/0.5/</p> <p>https://github.com/ome/ngff/tree/8cbba216e37407bd2d4bd5c7128ab13bd0a6404e</p> <p>Classes:</p> <ul> <li> <code>Dataset</code>           \u2013            </li> <li> <code>LabelImage</code>           \u2013            <p>Model for individual label images with multiscales + image-label metadata.</p> </li> <li> <code>LabelsGroup</code>           \u2013            <p>Model for the labels group that contains paths to individual label images.</p> </li> <li> <code>Multiscale</code>           \u2013            <p>A multiscale representation of an image.</p> </li> <li> <code>OMEAttributes</code>           \u2013            <p>The attributes field of a zarr.json document in an ome-zarr group.</p> </li> <li> <code>OMEZarrGroupJSON</code>           \u2013            <p>A zarr.json document found in any ome-zarr group.</p> </li> <li> <code>Omero</code>           \u2013            <p>A very rough/incomplete model of ImgData.</p> </li> <li> <code>PlateWell</code>           \u2013            <p>Individual well in a plate.</p> </li> <li> <code>Well</code>           \u2013            <p>A well at the top-level of an ome-zarr file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>OMEMetadata</code>               (<code>TypeAlias</code>)           \u2013            <p>Anything that can live in the \"ome\" key of a v0.5 ome-zarr file.</p> </li> </ul>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.OMEMetadata","title":"OMEMetadata  <code>module-attribute</code>","text":"<pre><code>OMEMetadata: TypeAlias = Annotated[\n    Annotated[LabelImage, Tag(\"label-image\")]\n    | Annotated[Image, Tag(\"image\")]\n    | Annotated[Plate, Tag(\"plate\")]\n    | Annotated[Bf2Raw, Tag(\"bf2raw\")]\n    | Annotated[Well, Tag(\"well\")]\n    | Annotated[LabelsGroup, Tag(\"labels-group\")]\n    | Annotated[Series, Tag(\"series\")],\n    Discriminator(_discriminate_ome_v05_metadata),\n]\n</code></pre> <p>Anything that can live in the \"ome\" key of a v0.5 ome-zarr file.</p>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.Dataset","title":"Dataset","text":"<p>               Bases: <code>_BaseModel</code></p> <p>Attributes:</p> <ul> <li> <code>scale_transform</code>               (<code>ScaleTransformation</code>)           \u2013            <p>Return the scale transformation from the list.</p> </li> </ul>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.Dataset.scale_transform","title":"scale_transform  <code>property</code>","text":"<pre><code>scale_transform: ScaleTransformation\n</code></pre> <p>Return the scale transformation from the list.</p> <p>(CoordinateTransformsList validator ensures there is exactly one.)</p>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.LabelImage","title":"LabelImage","text":"<p>               Bases: <code>Image</code></p> <p>Model for individual label images with multiscales + image-label metadata.</p>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.LabelsGroup","title":"LabelsGroup","text":"<p>               Bases: <code>_BaseModel</code></p> <p>Model for the labels group that contains paths to individual label images.</p>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.Multiscale","title":"Multiscale","text":"<p>               Bases: <code>_BaseModel</code></p> <p>A multiscale representation of an image.</p> Notes <p>Additional constraints that are not verifiable without I/O:</p> <ul> <li>The length of \"axes\" MUST be equal to the dimensionality of the zarr arrays   storing the image data (see <code>datasets.path</code>).</li> <li>The \"dimension_names\" attribute MUST be included in the zarr.json of the Zarr   array of a multiscale level and MUST match the names in the \"axes\" metadata.</li> <li>The order of axes in \"axes\" MUST match the order of dimensions in the zarr arrays.</li> <li>The \"paths\" of the datasets MUST be be ordered from the highest resolution to the   lowest resolution (i.e. largest to smallest)</li> </ul> <p>Methods:</p> <ul> <li> <code>from_dims</code>             \u2013              <p>Convenience constructor: Create Multiscale from a sequence of DimSpec.</p> </li> </ul>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.Multiscale.from_dims","title":"from_dims  <code>classmethod</code>","text":"<pre><code>from_dims(\n    dims: Sequence[DimSpec],\n    name: str | None = None,\n    n_levels: int = 1,\n) -&gt; Self\n</code></pre> <p>Convenience constructor: Create Multiscale from a sequence of DimSpec.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Multiscale</code>           \u2013            <p>A fully configured Multiscale model.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from yaozarrs import DimSpec, v05\n&gt;&gt;&gt; dims = [\n...     DimSpec(name=\"t\", size=512, unit=\"second\"),\n...     DimSpec(\n...         name=\"z\", size=50, scale=2.0, unit=\"micrometer\", scale_factor=1.0\n...     ),\n...     DimSpec(name=\"y\", size=512, scale=0.5, unit=\"micrometer\"),\n...     DimSpec(name=\"x\", size=512, scale=0.5, unit=\"micrometer\"),\n... ]\n&gt;&gt;&gt; v05.Multiscale.from_dims(dims, name=\"my_multiscale\", n_levels=3)\n</code></pre> Source code in <code>src/yaozarrs/v05/_image.py</code> <pre><code>@classmethod\ndef from_dims(\n    cls,\n    dims: Sequence[DimSpec],\n    name: str | None = None,\n    n_levels: int = 1,\n) -&gt; Self:\n    \"\"\"Convenience constructor: Create Multiscale from a sequence of DimSpec.\n\n    Parameters\n    ----------\n    dims : Sequence[DimSpec]\n        A sequence of dimension specifications defining the image dimensions.\n        Must follow OME-Zarr axis ordering: `[time,] [channel,] space...`\n    name : str | None, optional\n        Name for the multiscale. Default is None.\n    n_levels : int, optional\n        Number of resolution levels in the pyramid. Default is 1.\n\n    Returns\n    -------\n    Multiscale\n        A fully configured Multiscale model.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from yaozarrs import DimSpec, v05\n    &gt;&gt;&gt; dims = [\n    ...     DimSpec(name=\"t\", size=512, unit=\"second\"),\n    ...     DimSpec(\n    ...         name=\"z\", size=50, scale=2.0, unit=\"micrometer\", scale_factor=1.0\n    ...     ),\n    ...     DimSpec(name=\"y\", size=512, scale=0.5, unit=\"micrometer\"),\n    ...     DimSpec(name=\"x\", size=512, scale=0.5, unit=\"micrometer\"),\n    ... ]\n    &gt;&gt;&gt; v05.Multiscale.from_dims(dims, name=\"my_multiscale\", n_levels=3)\n    \"\"\"\n    from yaozarrs._dim_spec import _axes_datasets\n\n    return cls(name=name, **_axes_datasets(dims, n_levels))  # type: ignore\n</code></pre>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.Multiscale.from_dims(dims)","title":"<code>dims</code>","text":"(<code>Sequence[DimSpec]</code>)           \u2013            <p>A sequence of dimension specifications defining the image dimensions. Must follow OME-Zarr axis ordering: <code>[time,] [channel,] space...</code></p>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.Multiscale.from_dims(name)","title":"<code>name</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Name for the multiscale. Default is None.</p>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.Multiscale.from_dims(n_levels)","title":"<code>n_levels</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of resolution levels in the pyramid. Default is 1.</p>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.OMEAttributes","title":"OMEAttributes","text":"<p>               Bases: <code>_BaseModel</code></p> <p>The attributes field of a zarr.json document in an ome-zarr group.</p>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.OMEZarrGroupJSON","title":"OMEZarrGroupJSON","text":"<p>               Bases: <code>ZarrGroupModel</code></p> <p>A zarr.json document found in any ome-zarr group.</p>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.Omero","title":"Omero","text":"<p>               Bases: <code>_BaseModel</code></p> <p>A very rough/incomplete model of ImgData.</p> <p>https://omero.readthedocs.io/en/stable/developers/Web/WebGateway.html#imgdata</p> <p>Extra fields are allowed to accommodate missing fields.</p>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.PlateWell","title":"PlateWell","text":"<p>               Bases: <code>_BaseModel</code></p> <p>Individual well in a plate.</p>"},{"location":"reference/yaozarrs/v05/#yaozarrs.v05.Well","title":"Well","text":"<p>               Bases: <code>_BaseModel</code></p> <p>A well at the top-level of an ome-zarr file.</p>"},{"location":"reference/yaozarrs/write/","title":"write","text":""},{"location":"reference/yaozarrs/write/#yaozarrs.write","title":"yaozarrs.write","text":"<p>Write utilities for yaozarrs.</p> <p>Modules:</p> <ul> <li> <code>v05</code>           \u2013            <p>Writing utilities for OME-Zarr v0.5 format.</p> </li> </ul>"},{"location":"reference/yaozarrs/write/v05/","title":"v05","text":""},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05","title":"yaozarrs.write.v05","text":"<p>Writing utilities for OME-Zarr v0.5 format.</p> <p>Classes:</p> <ul> <li> <code>Bf2RawBuilder</code>           \u2013            <p>Builder for bioformats2raw layout hierarchies.</p> </li> <li> <code>LabelsBuilder</code>           \u2013            <p>Builder for labels groups within an Image.</p> </li> <li> <code>PlateBuilder</code>           \u2013            <p>Builder for OME-Zarr v0.5 Plate hierarchies with auto-generated metadata.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>prepare_image</code>             \u2013              <p>Create OME-Zarr v0.5 Image structure and return array handles for writing.</p> </li> <li> <code>write_bioformats2raw</code>             \u2013              <p>Write a bioformats2raw-layout OME-Zarr with multiple series.</p> </li> <li> <code>write_image</code>             \u2013              <p>Write an OME-Zarr v0.5 Image group with data.</p> </li> <li> <code>write_plate</code>             \u2013              <p>Write an OME-Zarr v0.5 Plate group with data.</p> </li> </ul>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder","title":"Bf2RawBuilder","text":"<pre><code>Bf2RawBuilder(\n    dest: str | PathLike,\n    *,\n    ome_xml: str | None = None,\n    writer: ZarrWriter = \"auto\",\n    chunks: ShapeLike | Literal[\"auto\"] | None = \"auto\",\n    shards: ShapeLike | None = None,\n    overwrite: bool = False,\n    compression: CompressionName = \"blosc-zstd\",\n)\n</code></pre> <p>Builder for bioformats2raw layout hierarchies.</p> <p>The bioformats2raw layout is a convention for storing multiple OME-Zarr images in a single hierarchy. It includes:</p> <ul> <li>A root group with <code>bioformats2raw.layout</code> version attribute</li> <li>An <code>OME/</code> subgroup listing all series names</li> <li>Each series as a separate Image subgroup (e.g., <code>0/</code>, <code>1/</code>)</li> <li>Optional <code>OME/METADATA.ome.xml</code> with full OME-XML metadata</li> </ul> <p>This builder supports two workflows:</p> <ol> <li> <p>Immediate write (simpler): Use <code>write_image()</code> to write each series    with its data immediately. The builder manages root structure and series    list automatically.</p> </li> <li> <p>Prepare-only (flexible): Use <code>add_series()</code> to register all series,    then <code>prepare()</code> to create the hierarchy with empty arrays. Write data    to the returned arrays yourself.</p> </li> </ol> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Examples:</p> <p>Immediate write workflow:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from yaozarrs import v05\n&gt;&gt;&gt; from yaozarrs.write.v05 import Bf2RawBuilder\n&gt;&gt;&gt; def make_image():\n...     return v05.Image(\n...         multiscales=[\n...             v05.Multiscale(\n...                 axes=[v05.SpaceAxis(name=\"y\"), v05.SpaceAxis(name=\"x\")],\n...                 datasets=[\n...                     v05.Dataset(\n...                         path=\"0\",\n...                         coordinateTransformations=[\n...                             v05.ScaleTransformation(scale=[1.0, 1.0])\n...                         ],\n...                     )\n...                 ],\n...             )\n...         ]\n...     )\n&gt;&gt;&gt; builder = Bf2RawBuilder(\"builder_immediate.zarr\")\n&gt;&gt;&gt; builder.write_image(\"0\", make_image(), np.zeros((32, 32), dtype=np.uint16))\n&lt;Bf2RawBuilder: 1 images&gt;\n&gt;&gt;&gt; builder.write_image(\"1\", make_image(), np.zeros((16, 16), dtype=np.uint16))\n&lt;Bf2RawBuilder: 2 images&gt;\n&gt;&gt;&gt; assert (builder.root_path / \"0\" / \"zarr.json\").exists()\n</code></pre> <p>Prepare-only workflow:</p> <pre><code>&gt;&gt;&gt; builder2 = Bf2RawBuilder(\"builder_prepare.zarr\")\n&gt;&gt;&gt; builder2.add_series(\"0\", make_image(), ((32, 32), np.uint16))  # shape, dtype\n&lt;Bf2RawBuilder: 1 images&gt;\n&gt;&gt;&gt; builder2.add_series(\"1\", make_image(), ((16, 16), np.uint16))\n&lt;Bf2RawBuilder: 2 images&gt;\n&gt;&gt;&gt; path, arrays = builder2.prepare()\n&gt;&gt;&gt; arrays[\"0/0\"][:] = np.zeros((32, 32), dtype=np.uint16)  # Write data yourself\n&gt;&gt;&gt; arrays[\"1/0\"][:] = np.zeros((16, 16), dtype=np.uint16)\n&gt;&gt;&gt; assert path.exists()\n</code></pre> See Also <p>write_bioformats2raw : High-level function to write all series at once.</p> <p>Methods:</p> <ul> <li> <code>add_series</code>             \u2013              <p>Add a series for the prepare-only workflow.</p> </li> <li> <code>prepare</code>             \u2013              <p>Create the Zarr hierarchy and return array handles.</p> </li> <li> <code>write_image</code>             \u2013              <p>Write a series immediately with its data.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>root_path</code>               (<code>Path</code>)           \u2013            <p>Path to the root of the bioformats2raw hierarchy.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def __init__(\n    self,\n    dest: str | PathLike,\n    *,\n    ome_xml: str | None = None,\n    writer: ZarrWriter = \"auto\",\n    chunks: ShapeLike | Literal[\"auto\"] | None = \"auto\",\n    shards: ShapeLike | None = None,\n    overwrite: bool = False,\n    compression: CompressionName = \"blosc-zstd\",\n) -&gt; None:\n    self._dest = Path(dest)\n    self._ome_xml = ome_xml\n    self._writer: ZarrWriter = writer\n    self._chunks: ShapeLike | Literal[\"auto\"] | None = chunks\n    self._shards = shards\n    self._overwrite = overwrite\n    self._compression: CompressionName = compression\n    self._indent = 2\n\n    # For prepare-only workflow: {series_name: (image, dataset_specs)}\n    self._series: dict[str, ImageWithShapeSpecs] = {}\n\n    # For immediate write workflow\n    self._initialized = False\n    self._written_series: list[str] = []\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder(dest)","title":"<code>dest</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>Destination path for the root Zarr group.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder(ome_xml)","title":"<code>ome_xml</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Original OME-XML string to store as <code>OME/METADATA.ome.xml</code>.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder(writer)","title":"<code>writer</code>","text":"(<code>'zarr' | 'tensorstore' | 'auto' | CreateArrayFunc</code>, default:                   <code>'auto'</code> )           \u2013            <p>Backend to use for writing arrays. Default is \"auto\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder(chunks)","title":"<code>chunks</code>","text":"(<code>tuple[int, ...] | 'auto' | None</code>, default:                   <code>'auto'</code> )           \u2013            <p>Chunk shape for all arrays. Default is \"auto\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder(shards)","title":"<code>shards</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Shard shape for Zarr v3 sharding. Default is None (no sharding). When present, shard_shape must be divisible by chunk shape.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite existing groups. Default is False. Note: existing directories that don't look like zarr groups will NOT be removed, an exception will be raised instead.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder(compression)","title":"<code>compression</code>","text":"(<code>'blosc-zstd' | 'blosc-lz4' | 'zstd' | 'none'</code>, default:                   <code>'blosc-zstd'</code> )           \u2013            <p>Compression codec. Default is \"blosc-zstd\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder.root_path","title":"root_path  <code>property</code>","text":"<pre><code>root_path: Path\n</code></pre> <p>Path to the root of the bioformats2raw hierarchy.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder.add_series","title":"add_series","text":"<pre><code>add_series(\n    name: str,\n    image: Image,\n    datasets: ShapeAndDTypeOrPyramid,\n) -&gt; Self\n</code></pre> <p>Add a series for the prepare-only workflow.</p> <p>Registers a series to be created when <code>prepare()</code> is called. Use this when you want to create the Zarr structure without writing data immediately. After calling <code>prepare()</code>, write data to the returned array handles.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The builder instance (for method chaining).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a series with this name was already added or written, or if the number of dataset specs doesn't match the metadata.</p> </li> <li> <code>NotImplementedError</code>             \u2013            <p>If the Image has multiple multiscales.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def add_series(\n    self,\n    name: str,\n    image: Image,\n    datasets: ShapeAndDTypeOrPyramid,\n) -&gt; Self:\n    \"\"\"Add a series for the prepare-only workflow.\n\n    Registers a series to be created when `prepare()` is called. Use this\n    when you want to create the Zarr structure without writing data\n    immediately. After calling `prepare()`, write data to the returned\n    array handles.\n\n    Parameters\n    ----------\n    name : str\n        Series name (becomes the subgroup path, e.g., \"0\", \"1\").\n    image : Image\n        OME-Zarr Image metadata model for this series.\n    datasets : ShapeAndDType | Sequence[ShapeAndDType]\n        Shape and dtype specification(s) for each resolution level, as\n        `(shape, dtype)` tuples. For a single dataset, pass the tuple\n        directly without wrapping in a list.\n\n    Returns\n    -------\n    Self\n        The builder instance (for method chaining).\n\n    Raises\n    ------\n    ValueError\n        If a series with this name was already added or written, or if the\n        number of dataset specs doesn't match the metadata.\n    NotImplementedError\n        If the Image has multiple multiscales.\n    \"\"\"\n    self._validate_series_name(name)\n    _, datasets_seq = _validate_and_normalize_datasets(\n        image, datasets, f\"Series '{name}': \"\n    )\n    self._series[name] = (image, datasets_seq)\n    return self\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder.add_series(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>Series name (becomes the subgroup path, e.g., \"0\", \"1\").</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder.add_series(image)","title":"<code>image</code>","text":"(<code>Image</code>)           \u2013            <p>OME-Zarr Image metadata model for this series.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder.add_series(datasets)","title":"<code>datasets</code>","text":"(<code>ShapeAndDType | Sequence[ShapeAndDType]</code>)           \u2013            <p>Shape and dtype specification(s) for each resolution level, as <code>(shape, dtype)</code> tuples. For a single dataset, pass the tuple directly without wrapping in a list.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder.prepare","title":"prepare","text":"<pre><code>prepare() -&gt; tuple[Path, dict[str, Any]]\n</code></pre> <p>Create the Zarr hierarchy and return array handles.</p> <p>Creates the complete bioformats2raw structure including root metadata, OME directory with series list, and empty arrays for all registered series. Call this after registering all series with <code>add_series()</code>.</p> <p>The returned arrays support numpy-style indexing for writing data: <code>arrays[\"series/dataset\"][:] = data</code>.</p> <p>Returns:</p> <ul> <li> <code>tuple[Path, dict[str, Any]]</code>           \u2013            <p>A tuple of (root_path, arrays) where <code>arrays</code> maps composite keys like <code>\"0/0\"</code> (series name / dataset path) to array objects. The array type depends on the configured writer (zarr.Array or tensorstore.TensorStore).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no series have been added with <code>add_series()</code>.</p> </li> <li> <code>FileExistsError</code>             \u2013            <p>If destination exists and <code>overwrite</code> is False.</p> </li> <li> <code>ImportError</code>             \u2013            <p>If no suitable writer backend is installed.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def prepare(self) -&gt; tuple[Path, dict[str, Any]]:\n    \"\"\"Create the Zarr hierarchy and return array handles.\n\n    Creates the complete bioformats2raw structure including root metadata,\n    OME directory with series list, and empty arrays for all registered\n    series. Call this after registering all series with `add_series()`.\n\n    The returned arrays support numpy-style indexing for writing data:\n    `arrays[\"series/dataset\"][:] = data`.\n\n    Returns\n    -------\n    tuple[Path, dict[str, Any]]\n        A tuple of (root_path, arrays) where `arrays` maps composite keys\n        like `\"0/0\"` (series name / dataset path) to array objects. The\n        array type depends on the configured writer (zarr.Array or\n        tensorstore.TensorStore).\n\n    Raises\n    ------\n    ValueError\n        If no series have been added with `add_series()`.\n    FileExistsError\n        If destination exists and `overwrite` is False.\n    ImportError\n        If no suitable writer backend is installed.\n    \"\"\"\n    if not self._series:  # pragma: no cover\n        raise ValueError(\"No series added. Use add_series() before prepare().\")\n\n    # Create root zarr.json with bioformats2raw.layout\n    bf2raw = Bf2Raw(bioformats2raw_layout=3)  # type: ignore\n    _create_zarr3_group(self._dest, bf2raw, self._overwrite)\n\n    # Create OME/zarr.json with series list\n    ome_path = self._dest / \"OME\"\n    series_model = Series(series=list(self._series))\n    _create_zarr3_group(ome_path, series_model, self._overwrite)\n\n    # Write METADATA.ome.xml if provided\n    if self._ome_xml is not None:\n        (ome_path / \"METADATA.ome.xml\").write_text(self._ome_xml)\n\n    # Create arrays for each series using prepare_image\n    all_arrays: dict[str, Any] = {}\n    for series_name, (image_model, dataset_specs) in self._series.items():\n        _root_path, series_arrays = prepare_image(\n            self._dest / series_name,\n            image_model,\n            dataset_specs,\n            chunks=self._chunks,\n            shards=self._shards,\n            writer=self._writer,\n            overwrite=self._overwrite,\n            compression=self._compression,\n        )\n        # Flatten into all_arrays with \"series/dataset\" keys\n        for dataset_path, arr in series_arrays.items():\n            all_arrays[f\"{series_name}/{dataset_path}\"] = arr\n\n    return self._dest, all_arrays\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder.write_image","title":"write_image","text":"<pre><code>write_image(\n    name: str,\n    image: Image,\n    datasets: ArrayOrPyramid,\n    *,\n    progress: bool = False,\n) -&gt; Self\n</code></pre> <p>Write a series immediately with its data.</p> <p>This method creates the series structure and writes data in one call. The root structure and OME metadata are created/updated automatically. Use this for the \"immediate write\" workflow.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The builder instance (for method chaining).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a series with this name was already written or added.</p> </li> <li> <code>NotImplementedError</code>             \u2013            <p>If the Image has multiple multiscales.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def write_image(\n    self,\n    name: str,\n    image: Image,\n    datasets: ArrayOrPyramid,\n    *,\n    progress: bool = False,\n) -&gt; Self:\n    \"\"\"Write a series immediately with its data.\n\n    This method creates the series structure and writes data in one call.\n    The root structure and OME metadata are created/updated automatically.\n    Use this for the \"immediate write\" workflow.\n\n    Parameters\n    ----------\n    name : str\n        Series name (becomes the subgroup path, e.g., \"0\", \"1\").\n    image : Image\n        OME-Zarr Image metadata model for this series.\n    datasets : ArrayLike | Sequence[ArrayLike]\n        Data array(s) for each resolution level. For a single dataset,\n        pass the array directly without wrapping in a list.\n    progress : bool, optional\n        Show progress bar when writing dask arrays. Default is False.\n\n    Returns\n    -------\n    Self\n        The builder instance (for method chaining).\n\n    Raises\n    ------\n    ValueError\n        If a series with this name was already written or added.\n    NotImplementedError\n        If the Image has multiple multiscales.\n    \"\"\"\n    self._validate_series_name(name)\n\n    # Initialize root structure if needed\n    self._ensure_initialized()\n\n    # Update OME/zarr.json with this series\n    self._update_ome_series(name)\n\n    # Write the series using the existing write_image function\n    write_image(\n        self._dest / name,\n        image,\n        datasets,\n        writer=self._writer,\n        chunks=self._chunks,\n        shards=self._shards,\n        overwrite=self._overwrite,\n        compression=self._compression,\n        progress=progress,\n    )\n\n    return self\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder.write_image(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>Series name (becomes the subgroup path, e.g., \"0\", \"1\").</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder.write_image(image)","title":"<code>image</code>","text":"(<code>Image</code>)           \u2013            <p>OME-Zarr Image metadata model for this series.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder.write_image(datasets)","title":"<code>datasets</code>","text":"(<code>ArrayLike | Sequence[ArrayLike]</code>)           \u2013            <p>Data array(s) for each resolution level. For a single dataset, pass the array directly without wrapping in a list.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.Bf2RawBuilder.write_image(progress)","title":"<code>progress</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Show progress bar when writing dask arrays. Default is False.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder","title":"LabelsBuilder","text":"<pre><code>LabelsBuilder(\n    dest: str | PathLike,\n    *,\n    writer: ZarrWriter = \"auto\",\n    chunks: ShapeLike | Literal[\"auto\"] | None = \"auto\",\n    shards: ShapeLike | None = None,\n    overwrite: bool = False,\n    compression: CompressionName = \"blosc-zstd\",\n)\n</code></pre> <p>Builder for labels groups within an Image.</p> <p>The labels group structure includes: - A labels group with LabelsGroup metadata listing all label names - Each label as a separate LabelImage subgroup (e.g., <code>cells/</code>, <code>nuclei/</code>)</p> <p>This builder supports two workflows:</p> <ol> <li> <p>Immediate write (simpler): Use <code>write_label()</code> to write each label    with its data immediately. The builder auto-generates and updates    LabelsGroup metadata after each call.</p> </li> <li> <p>Prepare-only (flexible): Use <code>add_label()</code> to register all labels,    then <code>prepare()</code> to create the hierarchy with empty arrays. Write data    to the returned array handles yourself.</p> </li> </ol> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Examples:</p> <p>Immediate write workflow:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from yaozarrs import v05\n&gt;&gt;&gt; from yaozarrs.write.v05 import LabelsBuilder\n&gt;&gt;&gt; def make_label_image():\n...     return v05.LabelImage(\n...         multiscales=[\n...             v05.Multiscale(\n...                 axes=[v05.SpaceAxis(name=\"y\"), v05.SpaceAxis(name=\"x\")],\n...                 datasets=[\n...                     v05.Dataset(\n...                         path=\"0\",\n...                         coordinateTransformations=[\n...                             v05.ScaleTransformation(scale=[1.0, 1.0])\n...                         ],\n...                     )\n...                 ],\n...             )\n...         ],\n...         image_label=v05.ImageLabel(),\n...     )\n&gt;&gt;&gt; builder = LabelsBuilder(\"my_image.zarr/labels\")\n&gt;&gt;&gt; builder.write_label(\n...     \"cells\", make_label_image(), np.zeros((64, 64), dtype=np.uint32)\n... )\n&lt;LabelsBuilder: 1 labels&gt;\n&gt;&gt;&gt; builder.write_label(\n...     \"nuclei\", make_label_image(), np.zeros((64, 64), dtype=np.uint32)\n... )\n&lt;LabelsBuilder: 2 labels&gt;\n</code></pre> <p>Prepare-only workflow:</p> <pre><code>&gt;&gt;&gt; builder2 = LabelsBuilder(\"my_image2.zarr/labels\")\n&gt;&gt;&gt; builder2.add_label(\n...     \"cells\",\n...     make_label_image(),\n...     ((64, 64), np.uint32),  # shape, dtype spec\n... )\n&lt;LabelsBuilder: 1 labels&gt;\n&gt;&gt;&gt; path, arrays = builder2.prepare()\n&gt;&gt;&gt; arrays[\"cells/0\"][:] = np.random.randint(0, 10, (64, 64), dtype=np.uint32)\n</code></pre> See Also <p>write_image : High-level function with labels parameter for writing everything at once.</p> <p>Methods:</p> <ul> <li> <code>add_label</code>             \u2013              <p>Add a label for the prepare-only workflow.</p> </li> <li> <code>prepare</code>             \u2013              <p>Create the Zarr hierarchy and return array handles.</p> </li> <li> <code>write_label</code>             \u2013              <p>Write a label immediately with its data.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>root_path</code>               (<code>Path</code>)           \u2013            <p>Path to the labels group.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def __init__(\n    self,\n    dest: str | PathLike,\n    *,\n    writer: ZarrWriter = \"auto\",\n    chunks: ShapeLike | Literal[\"auto\"] | None = \"auto\",\n    shards: ShapeLike | None = None,\n    overwrite: bool = False,\n    compression: CompressionName = \"blosc-zstd\",\n) -&gt; None:\n    self._dest = Path(dest)\n    self._writer: ZarrWriter = writer\n    self._chunks: ShapeLike | Literal[\"auto\"] | None = chunks\n    self._shards = shards\n    self._overwrite = overwrite\n    self._compression: CompressionName = compression\n\n    # For prepare-only workflow: {label_name: (LabelImage, specs)}\n    self._labels: dict[str, tuple[LabelImage, ShapeAndDTypeOrPyramid]] = {}\n\n    # For immediate write workflow\n    self._initialized = False\n    self._written_labels: list[str] = []\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder(dest)","title":"<code>dest</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>Destination path for the labels Zarr group (typically <code>image_path/labels</code>).</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder(writer)","title":"<code>writer</code>","text":"(<code>'zarr' | 'tensorstore' | 'auto' | CreateArrayFunc</code>, default:                   <code>'auto'</code> )           \u2013            <p>Backend to use for writing arrays. Default is \"auto\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder(chunks)","title":"<code>chunks</code>","text":"(<code>tuple[int, ...] | 'auto' | None</code>, default:                   <code>'auto'</code> )           \u2013            <p>Chunk shape for all arrays. Default is \"auto\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder(shards)","title":"<code>shards</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Shard shape for Zarr v3 sharding. Default is None (no sharding). When present, shard_shape must be divisible by chunk shape.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite existing groups. Default is False. Note: existing directories that don't look like zarr groups will NOT be removed, an exception will be raised instead.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder(compression)","title":"<code>compression</code>","text":"(<code>'blosc-zstd' | 'blosc-lz4' | 'zstd' | 'none'</code>, default:                   <code>'blosc-zstd'</code> )           \u2013            <p>Compression codec. Default is \"blosc-zstd\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder.root_path","title":"root_path  <code>property</code>","text":"<pre><code>root_path: Path\n</code></pre> <p>Path to the labels group.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder.add_label","title":"add_label","text":"<pre><code>add_label(\n    name: str,\n    label_image: LabelImage,\n    datasets: ShapeAndDTypeOrPyramid,\n) -&gt; Self\n</code></pre> <p>Add a label for the prepare-only workflow.</p> <p>Registers a label to be created when <code>prepare()</code> is called. Use this when you want to create the Zarr structure without writing data immediately. After calling <code>prepare()</code>, write data to the returned array handles.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The builder instance (for method chaining).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a label with this name was already added or written, or if the number of specs doesn't match the metadata.</p> </li> <li> <code>NotImplementedError</code>             \u2013            <p>If the LabelImage has multiple multiscales.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def add_label(\n    self,\n    name: str,\n    label_image: LabelImage,\n    datasets: ShapeAndDTypeOrPyramid,\n) -&gt; Self:\n    \"\"\"Add a label for the prepare-only workflow.\n\n    Registers a label to be created when `prepare()` is called. Use this\n    when you want to create the Zarr structure without writing data\n    immediately. After calling `prepare()`, write data to the returned\n    array handles.\n\n    Parameters\n    ----------\n    name : str\n        Label name (becomes the subgroup path, e.g., \"cells\", \"nuclei\").\n    label_image : LabelImage\n        OME-Zarr LabelImage metadata model for this label.\n    datasets : ShapeAndDTypeOrPyramid\n        Shape/dtype spec(s) for each resolution level:\n        - Single level: `(shape, dtype)`\n        - Multiple levels: `[(shape1, dtype1), (shape2, dtype2)]`\n\n    Returns\n    -------\n    Self\n        The builder instance (for method chaining).\n\n    Raises\n    ------\n    ValueError\n        If a label with this name was already added or written, or if the\n        number of specs doesn't match the metadata.\n    NotImplementedError\n        If the LabelImage has multiple multiscales.\n    \"\"\"\n    self._validate_label_name(name)\n    _, specs_seq = _validate_and_normalize_datasets(\n        label_image, datasets, f\"Label '{name}': \"\n    )\n    self._labels[name] = (label_image, specs_seq)\n    return self\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder.add_label(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>Label name (becomes the subgroup path, e.g., \"cells\", \"nuclei\").</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder.add_label(label_image)","title":"<code>label_image</code>","text":"(<code>LabelImage</code>)           \u2013            <p>OME-Zarr LabelImage metadata model for this label.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder.add_label(datasets)","title":"<code>datasets</code>","text":"(<code>ShapeAndDTypeOrPyramid</code>)           \u2013            <p>Shape/dtype spec(s) for each resolution level: - Single level: <code>(shape, dtype)</code> - Multiple levels: <code>[(shape1, dtype1), (shape2, dtype2)]</code></p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder.prepare","title":"prepare","text":"<pre><code>prepare() -&gt; tuple[Path, dict[str, Any]]\n</code></pre> <p>Create the Zarr hierarchy and return array handles.</p> <p>Creates the complete labels group structure including LabelsGroup metadata, and empty arrays for all registered labels. Call this after registering all labels with <code>add_label()</code>.</p> <p>The returned arrays support numpy-style indexing for writing data: <code>arrays[\"label_name/dataset\"][:] = data</code>.</p> <p>Returns:</p> <ul> <li> <code>tuple[Path, dict[str, Any]]</code>           \u2013            <p>A tuple of (root_path, arrays) where <code>arrays</code> maps composite keys like <code>\"cells/0\"</code> (label name / dataset path) to array objects. The array type depends on the configured writer (zarr.Array or tensorstore.TensorStore).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no labels have been added with <code>add_label()</code>.</p> </li> <li> <code>FileExistsError</code>             \u2013            <p>If destination exists and <code>overwrite</code> is False.</p> </li> <li> <code>ImportError</code>             \u2013            <p>If no suitable writer backend is installed.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def prepare(self) -&gt; tuple[Path, dict[str, Any]]:\n    \"\"\"Create the Zarr hierarchy and return array handles.\n\n    Creates the complete labels group structure including LabelsGroup\n    metadata, and empty arrays for all registered labels. Call this after\n    registering all labels with `add_label()`.\n\n    The returned arrays support numpy-style indexing for writing data:\n    `arrays[\"label_name/dataset\"][:] = data`.\n\n    Returns\n    -------\n    tuple[Path, dict[str, Any]]\n        A tuple of (root_path, arrays) where `arrays` maps composite keys\n        like `\"cells/0\"` (label name / dataset path) to array objects. The\n        array type depends on the configured writer (zarr.Array or\n        tensorstore.TensorStore).\n\n    Raises\n    ------\n    ValueError\n        If no labels have been added with `add_label()`.\n    FileExistsError\n        If destination exists and `overwrite` is False.\n    ImportError\n        If no suitable writer backend is installed.\n    \"\"\"\n    if not self._labels:  # pragma: no cover\n        raise ValueError(\"No labels added. Use add_label() before prepare().\")\n\n    # Create labels/zarr.json with LabelsGroup metadata\n    labels_group = LabelsGroup(labels=list(self._labels.keys()))\n    _create_zarr3_group(self._dest, labels_group, self._overwrite)\n\n    # Create arrays for each label using prepare_image\n    all_arrays: dict[str, Any] = {}\n    for label_name, (label_image, datasets) in self._labels.items():\n        _label_path, label_arrays = prepare_image(\n            self._dest / label_name,\n            label_image,\n            datasets,\n            chunks=self._chunks,\n            shards=self._shards,\n            writer=self._writer,\n            overwrite=self._overwrite,\n            compression=self._compression,\n        )\n        # Flatten into all_arrays with \"label_name/dataset\" keys\n        for dataset_path, arr in label_arrays.items():\n            all_arrays[f\"{label_name}/{dataset_path}\"] = arr\n\n    return self._dest, all_arrays\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder.write_label","title":"write_label","text":"<pre><code>write_label(\n    name: str,\n    label_image: LabelImage,\n    datasets: ArrayOrPyramid,\n    *,\n    progress: bool = False,\n) -&gt; Self\n</code></pre> <p>Write a label immediately with its data.</p> <p>This method creates the label structure and writes data in one call. The labels group structure and LabelsGroup metadata are created/updated automatically. Use this for the \"immediate write\" workflow.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The builder instance (for method chaining).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If a label with this name was already written or added.</p> </li> <li> <code>NotImplementedError</code>             \u2013            <p>If the LabelImage has multiple multiscales.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def write_label(\n    self,\n    name: str,\n    label_image: LabelImage,\n    datasets: ArrayOrPyramid,\n    *,\n    progress: bool = False,\n) -&gt; Self:\n    \"\"\"Write a label immediately with its data.\n\n    This method creates the label structure and writes data in one call.\n    The labels group structure and LabelsGroup metadata are created/updated\n    automatically. Use this for the \"immediate write\" workflow.\n\n    Parameters\n    ----------\n    name : str\n        Label name (becomes the subgroup path, e.g., \"cells\", \"nuclei\").\n    label_image : LabelImage\n        OME-Zarr LabelImage metadata model for this label.\n    datasets : ArrayLike | Sequence[ArrayLike]\n        Data array(s) for each resolution level. For a single dataset,\n        pass the array directly without wrapping in a list.\n    progress : bool, optional\n        Show progress bar for dask arrays. Default is False.\n\n    Returns\n    -------\n    Self\n        The builder instance (for method chaining).\n\n    Raises\n    ------\n    ValueError\n        If a label with this name was already written or added.\n    NotImplementedError\n        If the LabelImage has multiple multiscales.\n    \"\"\"\n    self._validate_label_name(name)\n\n    # Initialize labels group structure if needed\n    self._ensure_initialized()\n\n    # Update labels/zarr.json with this label\n    self._update_labels_group(name)\n\n    # Write the label using the existing write_image function\n    # (LabelImage is a subclass of Image)\n    write_image(\n        self._dest / name,\n        label_image,\n        datasets,\n        writer=self._writer,\n        chunks=self._chunks,\n        shards=self._shards,\n        overwrite=self._overwrite,\n        compression=self._compression,\n        progress=progress,\n    )\n\n    return self\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder.write_label(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>Label name (becomes the subgroup path, e.g., \"cells\", \"nuclei\").</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder.write_label(label_image)","title":"<code>label_image</code>","text":"(<code>LabelImage</code>)           \u2013            <p>OME-Zarr LabelImage metadata model for this label.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder.write_label(datasets)","title":"<code>datasets</code>","text":"(<code>ArrayLike | Sequence[ArrayLike]</code>)           \u2013            <p>Data array(s) for each resolution level. For a single dataset, pass the array directly without wrapping in a list.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.LabelsBuilder.write_label(progress)","title":"<code>progress</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Show progress bar for dask arrays. Default is False.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder","title":"PlateBuilder","text":"<pre><code>PlateBuilder(\n    dest: str | PathLike,\n    *,\n    plate: Plate | None = None,\n    writer: ZarrWriter = \"auto\",\n    chunks: ShapeLike | Literal[\"auto\"] | None = \"auto\",\n    shards: ShapeLike | None = None,\n    overwrite: bool = False,\n    compression: CompressionName = \"blosc-zstd\",\n)\n</code></pre> <p>Builder for OME-Zarr v0.5 Plate hierarchies with auto-generated metadata.</p> <p>The Plate hierarchy includes: - A root Plate group with metadata (auto-generated from written wells) - Well subgroups (e.g., A/1/, B/2/, etc...) each containing Well metadata - Field subgroups (e.g., 0/, 1/) within each well, each an Image</p> <p>This builder supports two workflows:</p> <ol> <li> <p>Immediate write (simpler): Use <code>write_well()</code> to write each well    with its field data immediately. The builder auto-generates and updates    plate metadata (rows, columns, wells) after each call, similar to how    Bf2RawBuilder auto-updates the series list.</p> </li> <li> <p>Prepare-only (flexible): Use <code>add_well()</code> to register all wells,    then <code>prepare()</code> to create the hierarchy with empty arrays. Plate    metadata is auto-generated from all registered wells.</p> </li> </ol> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Examples:</p> <p>Auto-generation workflow (recommended):</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from yaozarrs import v05\n&gt;&gt;&gt; from yaozarrs.write.v05 import PlateBuilder\n&gt;&gt;&gt;\n&gt;&gt;&gt; def make_image():\n...     return v05.Image(\n...         multiscales=[\n...             v05.Multiscale(\n...                 axes=[v05.SpaceAxis(name=\"y\"), v05.SpaceAxis(name=\"x\")],\n...                 datasets=[\n...                     v05.Dataset(\n...                         path=\"0\",\n...                         coordinateTransformations=[\n...                             v05.ScaleTransformation(scale=[1.0, 1.0])\n...                         ],\n...                     )\n...                 ],\n...             )\n...         ]\n...     )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # No plate metadata needed - it's auto-generated!\n&gt;&gt;&gt; builder = PlateBuilder(\"plate_auto.zarr\")\n&gt;&gt;&gt; builder.write_well(\n...     row=\"A\",\n...     col=\"1\",\n...     images={\"0\": (make_image(), np.zeros((32, 32), dtype=np.uint16))},\n... )\n&lt;PlateBuilder: 1 wells&gt;\n&gt;&gt;&gt; builder.write_well(\n...     row=\"A\",\n...     col=\"2\",\n...     images={\"0\": (make_image(), np.zeros((32, 32), dtype=np.uint16))},\n... )\n&lt;PlateBuilder: 2 wells&gt;\n&gt;&gt;&gt; assert (builder.root_path / \"zarr.json\").exists()  # Plate metadata auto-updated\n</code></pre> <p>With explicit plate metadata:</p> <pre><code>&gt;&gt;&gt; plate = v05.Plate(\n...     plate=v05.PlateDef(\n...         columns=[v05.Column(name=\"1\")],\n...         rows=[v05.Row(name=\"A\")],\n...         wells=[v05.PlateWell(path=\"A/1\", rowIndex=0, columnIndex=0)],\n...     )\n... )\n&gt;&gt;&gt; builder2 = PlateBuilder(\"plate_explicit.zarr\", plate=plate)\n&gt;&gt;&gt; builder2.write_well(\n...     row=\"A\",\n...     col=\"1\",\n...     images={\"0\": (make_image(), np.zeros((32, 32), dtype=np.uint16))},\n... )\n&lt;PlateBuilder: 1 wells&gt;\n</code></pre> See Also <p>write_plate : High-level function to write all wells at once.</p> <p>Methods:</p> <ul> <li> <code>add_well</code>             \u2013              <p>Add a well for the prepare-only workflow.</p> </li> <li> <code>prepare</code>             \u2013              <p>Create the Zarr hierarchy and return array handles.</p> </li> <li> <code>write_well</code>             \u2013              <p>Write a well immediately with its <code>images</code> (fields of view) and data.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>root_path</code>               (<code>Path</code>)           \u2013            <p>Path to the root of the plate hierarchy.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def __init__(\n    self,\n    dest: str | PathLike,\n    *,\n    plate: Plate | None = None,\n    writer: ZarrWriter = \"auto\",\n    chunks: ShapeLike | Literal[\"auto\"] | None = \"auto\",\n    shards: ShapeLike | None = None,\n    overwrite: bool = False,\n    compression: CompressionName = \"blosc-zstd\",\n) -&gt; None:\n    self._dest = Path(dest)\n    self._user_plate = plate  # Store user-provided plate (if any)\n    self._writer: ZarrWriter = writer\n    self._chunks: ShapeLike | Literal[\"auto\"] | None = chunks\n    self._shards = shards\n    self._overwrite = overwrite\n    self._compression: CompressionName = compression\n\n    # For prepare-only workflow: {well_path: {fov: (Image, specs)}}\n    self._wells: dict[str, dict[str, ImageWithShapeSpecs]] = {}\n\n    # For immediate write workflow\n    self._initialized = False\n    # Track written wells: {(row, col): {fov: (Image, datasets)}}\n    self._written_wells_data: dict[\n        tuple[str, str], dict[str, ImageWithDatasets]\n    ] = {}\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder(dest)","title":"<code>dest</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>Destination path for the Plate Zarr group.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder(plate)","title":"<code>plate</code>","text":"(<code>Plate | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional OME-Zarr Plate metadata model. If None (default), plate metadata (rows, columns, wells) is auto-generated from written/added wells. If provided, validates that written wells match the metadata.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder(writer)","title":"<code>writer</code>","text":"(<code>'zarr' | 'tensorstore' | 'auto' | CreateArrayFunc</code>, default:                   <code>'auto'</code> )           \u2013            <p>Backend to use for writing arrays. Default is \"auto\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder(chunks)","title":"<code>chunks</code>","text":"(<code>tuple[int, ...] | 'auto' | None</code>, default:                   <code>'auto'</code> )           \u2013            <p>Chunk shape for all arrays. Default is \"auto\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder(shards)","title":"<code>shards</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Shard shape for Zarr v3 sharding. Default is None (no sharding). When present, shard_shape must be divisible by chunk shape.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite existing groups. Default is False. Note: existing directories that don't look like zarr groups will NOT be removed, an exception will be raised instead.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder(compression)","title":"<code>compression</code>","text":"(<code>'blosc-zstd' | 'blosc-lz4' | 'zstd' | 'none'</code>, default:                   <code>'blosc-zstd'</code> )           \u2013            <p>Compression codec. Default is \"blosc-zstd\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder.root_path","title":"root_path  <code>property</code>","text":"<pre><code>root_path: Path\n</code></pre> <p>Path to the root of the plate hierarchy.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder.add_well","title":"add_well","text":"<pre><code>add_well(\n    *,\n    row: str,\n    col: str,\n    images: Mapping[str, ImageWithShapeSpecs],\n) -&gt; Self\n</code></pre> <p>Add a well for the prepare-only workflow.</p> <p>Registers a well with its fields to be created when <code>prepare()</code> is called. Use this when you want to create the Zarr structure without writing data immediately. After calling <code>prepare()</code>, write data to the returned array handles.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The builder instance (for method chaining).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If row/col combination was already added/written, or if a user- provided Plate doesn't include this well, or if field specs don't match Image metadata.</p> </li> <li> <code>NotImplementedError</code>             \u2013            <p>If any Image has multiple multiscales.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def add_well(\n    self,\n    *,\n    row: str,\n    col: str,\n    images: Mapping[str, ImageWithShapeSpecs],\n) -&gt; Self:\n    \"\"\"Add a well for the prepare-only workflow.\n\n    Registers a well with its fields to be created when `prepare()` is called.\n    Use this when you want to create the Zarr structure without writing data\n    immediately. After calling `prepare()`, write data to the returned array\n    handles.\n\n    Parameters\n    ----------\n    row : str\n        Row name like \"A\", \"B\", etc.\n    col : str\n        Column name like \"1\", \"2\", etc.\n    images : Mapping[str, ImageWithShapeSpecs]\n        Mapping of `{fov -&gt; (image_model, specs)}` where specs provide the\n        dtype and shape for each resolution level:\n        - Single level: `(image, (shape, dtype))`\n        - Multiple levels: `(image, [(shape1, dtype1), (shape2, dtype2)])`\n\n    Returns\n    -------\n    Self\n        The builder instance (for method chaining).\n\n    Raises\n    ------\n    ValueError\n        If row/col combination was already added/written, or if a user-\n        provided Plate doesn't include this well, or if field specs\n        don't match Image metadata.\n    NotImplementedError\n        If any Image has multiple multiscales.\n    \"\"\"\n    # Validate well hasn't been used\n    self._validate_well_coordinates(row, col)\n\n    # Validate and normalize all fields before accepting\n    well_path = f\"{row}/{col}\"\n    normalized_fields: dict[str, ImageWithShapeSpecs] = {}\n\n    for fov, (image_model, specs) in images.items():\n        _, specs_seq = _validate_and_normalize_datasets(\n            image_model, specs, f\"Well '{well_path}', field '{fov}': \"\n        )\n        normalized_fields[fov] = (image_model, specs_seq)\n\n    self._wells[well_path] = normalized_fields\n    return self\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder.add_well(row)","title":"<code>row</code>","text":"(<code>str</code>)           \u2013            <p>Row name like \"A\", \"B\", etc.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder.add_well(col)","title":"<code>col</code>","text":"(<code>str</code>)           \u2013            <p>Column name like \"1\", \"2\", etc.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder.add_well(images)","title":"<code>images</code>","text":"(<code>Mapping[str, ImageWithShapeSpecs]</code>)           \u2013            <p>Mapping of <code>{fov -&gt; (image_model, specs)}</code> where specs provide the dtype and shape for each resolution level: - Single level: <code>(image, (shape, dtype))</code> - Multiple levels: <code>(image, [(shape1, dtype1), (shape2, dtype2)])</code></p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder.prepare","title":"prepare","text":"<pre><code>prepare() -&gt; tuple[Path, dict[str, Any]]\n</code></pre> <p>Create the Zarr hierarchy and return array handles.</p> <p>Creates the complete Plate structure including plate metadata (auto- generated from registered wells), well subgroups with Well metadata, and empty arrays for all registered fields. Call this after registering all wells with <code>add_well()</code>.</p> <p>The returned arrays support numpy-style indexing for writing data: <code>arrays[\"well/field/dataset\"][:] = data</code>.</p> <p>Returns:</p> <ul> <li> <code>tuple[Path, dict[str, Any]]</code>           \u2013            <p>A tuple of (root_path, arrays) where <code>arrays</code> maps composite keys like <code>\"A/1/0/0\"</code> (well_path / field / dataset_path) to array objects. The array type depends on the configured writer (zarr.Array or tensorstore.TensorStore).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no wells have been added with <code>add_well()</code>.</p> </li> <li> <code>FileExistsError</code>             \u2013            <p>If destination exists and <code>overwrite</code> is False.</p> </li> <li> <code>ImportError</code>             \u2013            <p>If no suitable writer backend is installed.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def prepare(self) -&gt; tuple[Path, dict[str, Any]]:\n    \"\"\"Create the Zarr hierarchy and return array handles.\n\n    Creates the complete Plate structure including plate metadata (auto-\n    generated from registered wells), well subgroups with Well metadata,\n    and empty arrays for all registered fields. Call this after registering\n    all wells with `add_well()`.\n\n    The returned arrays support numpy-style indexing for writing data:\n    `arrays[\"well/field/dataset\"][:] = data`.\n\n    Returns\n    -------\n    tuple[Path, dict[str, Any]]\n        A tuple of (root_path, arrays) where `arrays` maps composite keys\n        like `\"A/1/0/0\"` (well_path / field / dataset_path) to array\n        objects. The array type depends on the configured writer\n        (zarr.Array or tensorstore.TensorStore).\n\n    Raises\n    ------\n    ValueError\n        If no wells have been added with `add_well()`.\n    FileExistsError\n        If destination exists and `overwrite` is False.\n    ImportError\n        If no suitable writer backend is installed.\n    \"\"\"\n    if not self._wells:\n        raise ValueError(\"No wells added. Use add_well() before prepare().\")\n\n    # Generate plate metadata from registered wells\n    plate = _merge_plate_metadata(self._get_images_dict(), self._user_plate)\n\n    # Create plate zarr.json\n    _create_zarr3_group(self._dest, plate, self._overwrite)\n\n    # Create arrays for each well/field combination\n    all_arrays: dict[str, Any] = {}\n\n    for well_path, fields in self._wells.items():\n        # Generate Well metadata and group\n        well_metadata = self._generate_well_metadata(list(fields))\n        well_group_path = self._dest / well_path\n        _create_zarr3_group(well_group_path, well_metadata, self._overwrite)\n\n        # Create arrays for each field\n        for fov, (image_model, datasets) in fields.items():\n            field_path = well_group_path / fov\n\n            _field_path, field_arrays = prepare_image(\n                field_path,\n                image_model,\n                datasets,\n                chunks=self._chunks,\n                shards=self._shards,\n                writer=self._writer,\n                overwrite=self._overwrite,\n                compression=self._compression,\n            )\n\n            # Flatten into all_arrays with \"well/field/dataset\" keys\n            for dataset_path, arr in field_arrays.items():\n                composite_key = f\"{well_path}/{fov}/{dataset_path}\"\n                all_arrays[composite_key] = arr\n\n    return self._dest, all_arrays\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder.write_well","title":"write_well","text":"<pre><code>write_well(\n    row: str,\n    col: str,\n    images: Mapping[str, ImageWithDatasets],\n    *,\n    progress: bool = False,\n) -&gt; Self\n</code></pre> <p>Write a well immediately with its <code>images</code> (fields of view) and data.</p> <p>This method creates the well structure and writes all field data in one call. The plate structure and well metadata are created/updated automatically. Plate metadata (rows, columns, wells) is auto-generated from all written wells and rewritten after each call.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The builder instance (for method chaining).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If row/col combination was already written or added, or if a user- provided Plate doesn't include this well.</p> </li> <li> <code>NotImplementedError</code>             \u2013            <p>If any Image has multiple multiscales.</p> </li> </ul> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def write_well(\n    self,\n    row: str,\n    col: str,\n    images: Mapping[str, ImageWithDatasets],\n    *,\n    progress: bool = False,\n) -&gt; Self:\n    \"\"\"Write a well immediately with its `images` (fields of view) and data.\n\n    This method creates the well structure and writes all field data in one\n    call. The plate structure and well metadata are created/updated\n    automatically. Plate metadata (rows, columns, wells) is auto-generated\n    from all written wells and rewritten after each call.\n\n    Parameters\n    ----------\n    row : str\n        Row name like \"A\", \"B\", etc.\n    col : str\n        Column name like \"1\", \"2\", etc.\n    images : Mapping[str, ImageWithDatasets]\n        Mapping of `{fov -&gt; (image_model, datasets)}` where:\n        - fov: Field of view identifier like \"0\", \"1\", etc.\n        - datasets can be:\n          - Single array (for one dataset): `{\"0\": (image, data)}`\n          - Sequence (for multiple datasets): `{\"0\": (image, [data1, data2])}`\n    progress : bool, optional\n        Show progress bar for dask arrays. Default is False.\n\n    Returns\n    -------\n    Self\n        The builder instance (for method chaining).\n\n    Raises\n    ------\n    ValueError\n        If row/col combination was already written or added, or if a user-\n        provided Plate doesn't include this well.\n    NotImplementedError\n        If any Image has multiple multiscales.\n    \"\"\"\n    # Validate well hasn't been used\n    self._validate_well_coordinates(row, col)\n\n    # Initialize plate structure if needed\n    self._ensure_initialized()\n\n    # Normalize fields (convert single arrays to sequences)\n    normalized_fields: dict[str, tuple[Image, Sequence[ArrayLike]]] = {}\n    for fov, (image_model, datasets) in images.items():\n        _, datasets_seq = _validate_and_normalize_datasets(\n            image_model, datasets, f\"Well '{row}/{col}', field '{fov}': \"\n        )\n        normalized_fields[fov] = (image_model, datasets_seq)\n\n    # Track this well's data before writing\n    self._written_wells_data[(row, col)] = cast(\n        \"dict[str, ImageWithDatasets]\", normalized_fields\n    )\n\n    # Update plate metadata with the new well\n    self._update_plate_metadata()\n\n    # Generate Well metadata for this well and create well subgroup\n    well_group_path = self._dest / f\"{row}/{col}\"\n    well_metadata = self._generate_well_metadata(list(images))\n    _create_zarr3_group(well_group_path, well_metadata, self._overwrite)\n\n    # Write each field of view\n    for fov, (image_model, datasets_seq) in normalized_fields.items():\n        field_path = well_group_path / fov\n        write_image(\n            field_path,\n            image_model,\n            datasets_seq,\n            writer=self._writer,\n            chunks=self._chunks,\n            shards=self._shards,\n            overwrite=self._overwrite,\n            compression=self._compression,\n            progress=progress,\n        )\n\n    return self\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder.write_well(row)","title":"<code>row</code>","text":"(<code>str</code>)           \u2013            <p>Row name like \"A\", \"B\", etc.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder.write_well(col)","title":"<code>col</code>","text":"(<code>str</code>)           \u2013            <p>Column name like \"1\", \"2\", etc.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder.write_well(images)","title":"<code>images</code>","text":"(<code>Mapping[str, ImageWithDatasets]</code>)           \u2013            <p>Mapping of <code>{fov -&gt; (image_model, datasets)}</code> where: - fov: Field of view identifier like \"0\", \"1\", etc. - datasets can be:   - Single array (for one dataset): <code>{\"0\": (image, data)}</code>   - Sequence (for multiple datasets): <code>{\"0\": (image, [data1, data2])}</code></p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.PlateBuilder.write_well(progress)","title":"<code>progress</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Show progress bar for dask arrays. Default is False.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.prepare_image","title":"prepare_image","text":"<pre><code>prepare_image(\n    dest: str | PathLike,\n    image: Image,\n    datasets: ShapeAndDTypeOrPyramid,\n    *,\n    writer: Literal[\"zarr\"],\n    chunks: tuple[int, ...] | Literal[\"auto\"] | None = ...,\n    shards: tuple[int, ...] | None = ...,\n    overwrite: bool = ...,\n    compression: CompressionName = ...,\n) -&gt; tuple[Path, dict[str, zarr.Array]]\n</code></pre><pre><code>prepare_image(\n    dest: str | PathLike,\n    image: Image,\n    datasets: ShapeAndDTypeOrPyramid,\n    *,\n    writer: Literal[\"tensorstore\"],\n    chunks: tuple[int, ...] | Literal[\"auto\"] | None = ...,\n    shards: tuple[int, ...] | None = ...,\n    overwrite: bool = ...,\n    compression: CompressionName = ...,\n) -&gt; tuple[Path, dict[str, tensorstore.TensorStore]]\n</code></pre><pre><code>prepare_image(\n    dest: str | PathLike,\n    image: Image,\n    datasets: ShapeAndDTypeOrPyramid,\n    *,\n    writer: Literal[\"auto\"] | CreateArrayFunc = ...,\n    chunks: tuple[int, ...] | Literal[\"auto\"] | None = ...,\n    shards: tuple[int, ...] | None = ...,\n    overwrite: bool = ...,\n    compression: CompressionName = ...,\n) -&gt; tuple[Path, dict[str, AnyZarrArray]]\n</code></pre> <pre><code>prepare_image(\n    dest: str | PathLike,\n    image: Image,\n    datasets: ShapeAndDTypeOrPyramid,\n    *,\n    chunks: tuple[int, ...]\n    | Literal[\"auto\"]\n    | None = \"auto\",\n    shards: tuple[int, ...] | None = None,\n    writer: ZarrWriter = \"auto\",\n    overwrite: bool = False,\n    compression: CompressionName = \"blosc-zstd\",\n) -&gt; tuple[Path, dict[str, Any]]\n</code></pre> <p>Create OME-Zarr v0.5 Image structure and return array handles for writing.</p> <p>This is a lower-level function that creates the Zarr group hierarchy and empty arrays, but does not write data. Use this when you need custom control over how data is written (e.g., chunk-by-chunk streaming, parallel writes).</p> <p>To write data immediately, use <code>write_image</code> instead.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[Path, dict[str, Array]]</code>           \u2013            <p>A tuple of (path, arrays) where <code>arrays</code> maps dataset paths (e.g., \"0\") to array objects. The array type depends on the writer:</p> <ul> <li><code>writer=\"zarr\"</code>: Returns <code>dict[str, zarr.Array]</code></li> <li><code>writer=\"tensorstore\"</code>: Returns <code>dict[str, tensorstore.TensorStore]</code></li> <li><code>writer=\"auto\"</code>: Returns whichever is available</li> </ul> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If the Image model has multiple multiscales.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the number of dataset specs doesn't match the metadata.</p> </li> <li> <code>FileExistsError</code>             \u2013            <p>If <code>dest</code> exists and <code>overwrite</code> is False.</p> </li> <li> <code>ImportError</code>             \u2013            <p>If no suitable writer backend is installed.</p> </li> </ul> <p>Examples:</p> <p>Create arrays and write data in chunks - single dataset, no list needed:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from yaozarrs import v05\n&gt;&gt;&gt; from yaozarrs.write.v05 import prepare_image\n&gt;&gt;&gt; image = v05.Image(\n...     multiscales=[\n...         v05.Multiscale(\n...             axes=[\n...                 v05.SpaceAxis(name=\"y\", unit=\"micrometer\"),\n...                 v05.SpaceAxis(name=\"x\", unit=\"micrometer\"),\n...             ],\n...             datasets=[\n...                 v05.Dataset(\n...                     path=\"0\",\n...                     coordinateTransformations=[\n...                         v05.ScaleTransformation(scale=[0.5, 0.5])\n...                     ],\n...                 )\n...             ],\n...         )\n...     ]\n... )\n&gt;&gt;&gt; # Prepare with just shape/dtype (no data yet) - no list wrapping!\n&gt;&gt;&gt; path, arrays = prepare_image(\"prepared.zarr\", image, ((64, 64), \"uint16\"))\n&gt;&gt;&gt; arrays[\"0\"][:] = np.zeros((64, 64), dtype=np.uint16)\n&gt;&gt;&gt; assert path.exists()\n</code></pre> See Also <p>write_image : High-level function that writes data immediately. Bf2RawBuilder.prepare : Prepare multiple series at once.</p> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def prepare_image(\n    dest: str | PathLike,\n    image: Image,\n    datasets: ShapeAndDTypeOrPyramid,\n    *,\n    chunks: tuple[int, ...] | Literal[\"auto\"] | None = \"auto\",\n    shards: tuple[int, ...] | None = None,\n    writer: ZarrWriter = \"auto\",\n    overwrite: bool = False,\n    compression: CompressionName = \"blosc-zstd\",\n) -&gt; tuple[Path, dict[str, Any]]:\n    \"\"\"Create OME-Zarr v0.5 Image structure and return array handles for writing.\n\n    This is a lower-level function that creates the Zarr group hierarchy and\n    empty arrays, but does not write data. Use this when you need custom control\n    over how data is written (e.g., chunk-by-chunk streaming, parallel writes).\n\n    To write data immediately, use `write_image` instead.\n\n    Parameters\n    ----------\n    dest : str | PathLike\n        Destination path for the Zarr group.\n    image : Image\n        OME-Zarr Image metadata model.\n    datasets : ShapeAndDType | Sequence[ShapeAndDType]\n        Shape and dtype specification(s) for each dataset, as `(shape, dtype)`\n        tuples. Can be:\n\n        - Single `(shape, dtype)`: For one dataset, no wrapping needed\n        - Sequence of `(shape, dtype)`: For multiple datasets (multiscale pyramid)\n\n        Must match the number and order of `image.multiscales[0].datasets`.\n    chunks : tuple[int, ...] | \"auto\" | None, optional\n        Chunk shape. See `write_image` for details.\n    shards : tuple[int, ...] | None, optional\n        Shard shape for Zarr v3 sharding. Default is None (no sharding).\n        When present, shard_shape must be divisible by chunk shape.\n    writer : \"zarr\" | \"tensorstore\" | \"auto\" | CreateArrayFunc, optional\n        Backend for creating arrays. When you specify \"zarr\" or \"tensorstore\",\n        the return type is narrowed to the specific array type.\n    overwrite : bool, optional\n        If True, overwrite existing Zarr group. Default is False.\n    compression : \"blosc-zstd\" | \"blosc-lz4\" | \"zstd\" | \"none\", optional\n        Compression codec. Default is \"blosc-zstd\".\n\n    Returns\n    -------\n    tuple[Path, dict[str, Array]]\n        A tuple of (path, arrays) where `arrays` maps dataset paths (e.g., \"0\")\n        to array objects. The array type depends on the writer:\n\n        - `writer=\"zarr\"`: Returns `dict[str, zarr.Array]`\n        - `writer=\"tensorstore\"`: Returns `dict[str, tensorstore.TensorStore]`\n        - `writer=\"auto\"`: Returns whichever is available\n\n    Raises\n    ------\n    NotImplementedError\n        If the Image model has multiple multiscales.\n    ValueError\n        If the number of dataset specs doesn't match the metadata.\n    FileExistsError\n        If `dest` exists and `overwrite` is False.\n    ImportError\n        If no suitable writer backend is installed.\n\n    Examples\n    --------\n    Create arrays and write data in chunks - single dataset, no list needed:\n\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from yaozarrs import v05\n    &gt;&gt;&gt; from yaozarrs.write.v05 import prepare_image\n    &gt;&gt;&gt; image = v05.Image(\n    ...     multiscales=[\n    ...         v05.Multiscale(\n    ...             axes=[\n    ...                 v05.SpaceAxis(name=\"y\", unit=\"micrometer\"),\n    ...                 v05.SpaceAxis(name=\"x\", unit=\"micrometer\"),\n    ...             ],\n    ...             datasets=[\n    ...                 v05.Dataset(\n    ...                     path=\"0\",\n    ...                     coordinateTransformations=[\n    ...                         v05.ScaleTransformation(scale=[0.5, 0.5])\n    ...                     ],\n    ...                 )\n    ...             ],\n    ...         )\n    ...     ]\n    ... )\n    &gt;&gt;&gt; # Prepare with just shape/dtype (no data yet) - no list wrapping!\n    &gt;&gt;&gt; path, arrays = prepare_image(\"prepared.zarr\", image, ((64, 64), \"uint16\"))\n    &gt;&gt;&gt; arrays[\"0\"][:] = np.zeros((64, 64), dtype=np.uint16)\n    &gt;&gt;&gt; assert path.exists()\n\n    See Also\n    --------\n    write_image : High-level function that writes data immediately.\n    Bf2RawBuilder.prepare : Prepare multiple series at once.\n    \"\"\"\n    if len(image.multiscales) != 1:\n        raise NotImplementedError(\"Image must have exactly one multiscale\")\n\n    multiscale = image.multiscales[0]\n\n    # Normalize to sequence: single (shape, dtype) tuple -&gt; list\n    datasets_seq: Sequence[ShapeAndDType]\n    if (\n        isinstance(datasets, tuple)\n        and len(datasets) == 2\n        and isinstance(datasets[0], tuple)  # shape is first element\n    ):\n        datasets_seq = [datasets]  # type: ignore[list-item]\n    else:\n        datasets_seq = datasets  # type: ignore[assignment]\n\n    if len(datasets_seq) != len(multiscale.datasets):\n        raise ValueError(\n            f\"Number of dataset specs ({len(datasets_seq)}) must match \"\n            f\"number of datasets in metadata ({len(multiscale.datasets)})\"\n        )\n\n    # Get create function\n    create_func = _get_create_func(writer)\n\n    # Create zarr group with Image metadata\n    dest_path = Path(dest)\n    _create_zarr3_group(dest_path, image, overwrite)\n\n    dimension_names = [ax.name for ax in multiscale.axes]\n\n    # Create arrays for each dataset\n    arrays = {}\n    for (shape, dtype_spec), dataset_meta in zip(datasets_seq, multiscale.datasets):\n        # Convert dtype to np.dtype to ensure compatibility with all backends\n        import numpy as np\n\n        dtype = np.dtype(dtype_spec)\n        arrays[dataset_meta.path] = create_func(\n            path=dest_path / dataset_meta.path,\n            shape=shape,\n            dtype=dtype,\n            chunks=_resolve_chunks(shape, dtype, chunks),\n            shards=shards,\n            dimension_names=dimension_names,\n            overwrite=overwrite,\n            compression=compression,\n        )\n\n    return dest_path, arrays\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.prepare_image(dest)","title":"<code>dest</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>Destination path for the Zarr group.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.prepare_image(image)","title":"<code>image</code>","text":"(<code>Image</code>)           \u2013            <p>OME-Zarr Image metadata model.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.prepare_image(datasets)","title":"<code>datasets</code>","text":"(<code>ShapeAndDType | Sequence[ShapeAndDType]</code>)           \u2013            <p>Shape and dtype specification(s) for each dataset, as <code>(shape, dtype)</code> tuples. Can be:</p> <ul> <li>Single <code>(shape, dtype)</code>: For one dataset, no wrapping needed</li> <li>Sequence of <code>(shape, dtype)</code>: For multiple datasets (multiscale pyramid)</li> </ul> <p>Must match the number and order of <code>image.multiscales[0].datasets</code>.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.prepare_image(chunks)","title":"<code>chunks</code>","text":"(<code>tuple[int, ...] | 'auto' | None</code>, default:                   <code>'auto'</code> )           \u2013            <p>Chunk shape. See <code>write_image</code> for details.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.prepare_image(shards)","title":"<code>shards</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Shard shape for Zarr v3 sharding. Default is None (no sharding). When present, shard_shape must be divisible by chunk shape.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.prepare_image(writer)","title":"<code>writer</code>","text":"(<code>'zarr' | 'tensorstore' | 'auto' | CreateArrayFunc</code>, default:                   <code>'auto'</code> )           \u2013            <p>Backend for creating arrays. When you specify \"zarr\" or \"tensorstore\", the return type is narrowed to the specific array type.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.prepare_image(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite existing Zarr group. Default is False.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.prepare_image(compression)","title":"<code>compression</code>","text":"(<code>'blosc-zstd' | 'blosc-lz4' | 'zstd' | 'none'</code>, default:                   <code>'blosc-zstd'</code> )           \u2013            <p>Compression codec. Default is \"blosc-zstd\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_bioformats2raw","title":"write_bioformats2raw","text":"<pre><code>write_bioformats2raw(\n    dest: str | PathLike,\n    images: Mapping[str, ImageWithDatasets],\n    *,\n    ome_xml: str | None = None,\n    writer: ZarrWriter = \"auto\",\n    overwrite: bool = False,\n    chunks: tuple[int, ...]\n    | Literal[\"auto\"]\n    | None = \"auto\",\n    shards: tuple[int, ...] | None = None,\n    compression: CompressionName = \"blosc-zstd\",\n    progress: bool = False,\n) -&gt; Path\n</code></pre> <p>Write a bioformats2raw-layout OME-Zarr with multiple series.</p> <p>The bioformats2raw layout is a convention for storing multiple images (series) in a single Zarr hierarchy. It includes a root group with <code>bioformats2raw.layout</code> version, an <code>OME/</code> group with series metadata, and each series as a separate Image subgroup.</p> <p>This is the high-level function for writing all series at once. For incremental writes, use <code>Bf2RawBuilder</code> directly.</p> <p>Writes the following structure:</p> <pre><code>dest/\n\u251c\u2500\u2500 zarr.json              # root: attributes[\"ome\"][\"bioformats2raw.layout\"]\n\u251c\u2500\u2500 0/                     # first series (images[\"0\"])\n\u2502   \u251c\u2500\u2500 zarr.json          # Image metadata (images[\"0\"][0])\n\u2502   \u251c\u2500\u2500 0/                 # first resolution level\n\u2502   \u2502   \u251c\u2500\u2500 zarr.json      # array metadata\n\u2502   \u2502   \u2514\u2500\u2500 c/             # chunks directory\n\u2502   \u2514\u2500\u2500 1/                 # second resolution level (if multiscale)\n\u2502       \u251c\u2500\u2500 zarr.json\n\u2502       \u2514\u2500\u2500 c/\n\u251c\u2500\u2500 1/                     # second series (images[\"1\"])\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 OME/\n    \u251c\u2500\u2500 zarr.json          # attributes[\"ome\"][\"series\"] = [\"0\", \"1\", ...]\n    \u2514\u2500\u2500 METADATA.ome.xml   # optional OME-XML (if ome_xml provided)\n</code></pre> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Path to the root Zarr group.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileExistsError</code>             \u2013            <p>If <code>dest</code> exists and <code>overwrite</code> is False.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If any series has mismatched datasets/metadata.</p> </li> <li> <code>ImportError</code>             \u2013            <p>If no suitable writer backend is installed.</p> </li> </ul> <p>Examples:</p> <p>Write a multi-series OME-Zarr:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from yaozarrs import v05\n&gt;&gt;&gt; from yaozarrs.write.v05 import write_bioformats2raw\n&gt;&gt;&gt;\n&gt;&gt;&gt; def make_image():\n...     return v05.Image(\n...         multiscales=[\n...             v05.Multiscale(\n...                 axes=[\n...                     v05.SpaceAxis(name=\"y\", unit=\"micrometer\"),\n...                     v05.SpaceAxis(name=\"x\", unit=\"micrometer\"),\n...                 ],\n...                 datasets=[\n...                     v05.Dataset(\n...                         path=\"0\",\n...                         coordinateTransformations=[\n...                             v05.ScaleTransformation(scale=[0.5, 0.5])\n...                         ],\n...                     )\n...                 ],\n...             )\n...         ]\n...     )\n&gt;&gt;&gt; images = {\n...     \"0\": (make_image(), [np.zeros((64, 64), dtype=np.uint16)]),\n...     \"1\": (make_image(), [np.zeros((32, 32), dtype=np.uint16)]),\n... }\n&gt;&gt;&gt; result = write_bioformats2raw(\"multi_series.zarr\", images)\n&gt;&gt;&gt; (result / \"OME\" / \"zarr.json\").exists()\nTrue\n&gt;&gt;&gt; (result / \"0\" / \"zarr.json\").exists()\nTrue\n</code></pre> See Also <p>Bf2RawBuilder : Builder class for incremental series writing. write_image : Write a single Image group.</p> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def write_bioformats2raw(\n    dest: str | PathLike,\n    # mapping of {series_name -&gt; ( Image, [datasets, ...] )}\n    images: Mapping[str, ImageWithDatasets],\n    *,\n    ome_xml: str | None = None,\n    writer: ZarrWriter = \"auto\",\n    overwrite: bool = False,\n    chunks: tuple[int, ...] | Literal[\"auto\"] | None = \"auto\",\n    shards: tuple[int, ...] | None = None,\n    compression: CompressionName = \"blosc-zstd\",\n    progress: bool = False,\n) -&gt; Path:\n    \"\"\"Write a bioformats2raw-layout OME-Zarr with multiple series.\n\n    The bioformats2raw layout is a convention for storing multiple images\n    (series) in a single Zarr hierarchy. It includes a root group with\n    `bioformats2raw.layout` version, an `OME/` group with series metadata,\n    and each series as a separate Image subgroup.\n\n    This is the high-level function for writing all series at once. For\n    incremental writes, use `Bf2RawBuilder` directly.\n\n    Writes the following structure:\n\n        dest/\n        \u251c\u2500\u2500 zarr.json              # root: attributes[\"ome\"][\"bioformats2raw.layout\"]\n        \u251c\u2500\u2500 0/                     # first series (images[\"0\"])\n        \u2502   \u251c\u2500\u2500 zarr.json          # Image metadata (images[\"0\"][0])\n        \u2502   \u251c\u2500\u2500 0/                 # first resolution level\n        \u2502   \u2502   \u251c\u2500\u2500 zarr.json      # array metadata\n        \u2502   \u2502   \u2514\u2500\u2500 c/             # chunks directory\n        \u2502   \u2514\u2500\u2500 1/                 # second resolution level (if multiscale)\n        \u2502       \u251c\u2500\u2500 zarr.json\n        \u2502       \u2514\u2500\u2500 c/\n        \u251c\u2500\u2500 1/                     # second series (images[\"1\"])\n        \u2502   \u2514\u2500\u2500 ...\n        \u2514\u2500\u2500 OME/\n            \u251c\u2500\u2500 zarr.json          # attributes[\"ome\"][\"series\"] = [\"0\", \"1\", ...]\n            \u2514\u2500\u2500 METADATA.ome.xml   # optional OME-XML (if ome_xml provided)\n\n    Parameters\n    ----------\n    dest : str | PathLike\n        Destination path for the root Zarr group.\n    images : dict[str, ImageWithDatasets]\n        Mapping of `{series_name -&gt; (image_model, [datasets, ...])}`.\n        Each series name (e.g., \"0\", \"1\") becomes a subgroup in the root group, with\n        the Image model defining the zarr.json and the datasets providing the data\n        arrays.\n    ome_xml : str | None, optional\n        OME-XML string to store as `OME/METADATA.ome.xml`.\n        Useful for preserving full metadata from converted files.\n    writer : \"zarr\" | \"tensorstore\" | \"auto\" | CreateArrayFunc, optional\n        Backend to use for writing arrays.\n    overwrite : bool, optional\n        If True, overwrite existing Zarr groups. Default is False.\n    chunks : tuple[int, ...] | \"auto\" | None, optional\n        Chunk shape for all arrays. See `write_image` for details.\n    shards : tuple[int, ...] | None, optional\n        Shard shape for Zarr v3 sharding. Default is None (no sharding).\n        When present, shard_shape must be divisible by chunk shape.\n    compression : \"blosc-zstd\" | \"blosc-lz4\" | \"zstd\" | \"none\", optional\n        Compression codec. Default is \"blosc-zstd\".\n    progress : bool, optional\n        Show progress bar when writing dask arrays. Default is False.\n\n    Returns\n    -------\n    Path\n        Path to the root Zarr group.\n\n    Raises\n    ------\n    FileExistsError\n        If `dest` exists and `overwrite` is False.\n    ValueError\n        If any series has mismatched datasets/metadata.\n    ImportError\n        If no suitable writer backend is installed.\n\n    Examples\n    --------\n    Write a multi-series OME-Zarr:\n\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; from yaozarrs import v05\n    &gt;&gt;&gt; from yaozarrs.write.v05 import write_bioformats2raw\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def make_image():\n    ...     return v05.Image(\n    ...         multiscales=[\n    ...             v05.Multiscale(\n    ...                 axes=[\n    ...                     v05.SpaceAxis(name=\"y\", unit=\"micrometer\"),\n    ...                     v05.SpaceAxis(name=\"x\", unit=\"micrometer\"),\n    ...                 ],\n    ...                 datasets=[\n    ...                     v05.Dataset(\n    ...                         path=\"0\",\n    ...                         coordinateTransformations=[\n    ...                             v05.ScaleTransformation(scale=[0.5, 0.5])\n    ...                         ],\n    ...                     )\n    ...                 ],\n    ...             )\n    ...         ]\n    ...     )\n    &gt;&gt;&gt; images = {\n    ...     \"0\": (make_image(), [np.zeros((64, 64), dtype=np.uint16)]),\n    ...     \"1\": (make_image(), [np.zeros((32, 32), dtype=np.uint16)]),\n    ... }\n    &gt;&gt;&gt; result = write_bioformats2raw(\"multi_series.zarr\", images)\n    &gt;&gt;&gt; (result / \"OME\" / \"zarr.json\").exists()\n    True\n    &gt;&gt;&gt; (result / \"0\" / \"zarr.json\").exists()\n    True\n\n    See Also\n    --------\n    Bf2RawBuilder : Builder class for incremental series writing.\n    write_image : Write a single Image group.\n    \"\"\"\n    builder = Bf2RawBuilder(\n        dest,\n        ome_xml=ome_xml,\n        writer=writer,\n        chunks=chunks,\n        shards=shards,\n        overwrite=overwrite,\n        compression=compression,\n    )\n\n    for series_name, (image_model, datasets) in images.items():\n        builder.write_image(series_name, image_model, datasets, progress=progress)\n\n    return builder.root_path\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_bioformats2raw(dest)","title":"<code>dest</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>Destination path for the root Zarr group.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_bioformats2raw(images)","title":"<code>images</code>","text":"(<code>dict[str, ImageWithDatasets]</code>)           \u2013            <p>Mapping of <code>{series_name -&gt; (image_model, [datasets, ...])}</code>. Each series name (e.g., \"0\", \"1\") becomes a subgroup in the root group, with the Image model defining the zarr.json and the datasets providing the data arrays.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_bioformats2raw(ome_xml)","title":"<code>ome_xml</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>OME-XML string to store as <code>OME/METADATA.ome.xml</code>. Useful for preserving full metadata from converted files.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_bioformats2raw(writer)","title":"<code>writer</code>","text":"(<code>'zarr' | 'tensorstore' | 'auto' | CreateArrayFunc</code>, default:                   <code>'auto'</code> )           \u2013            <p>Backend to use for writing arrays.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_bioformats2raw(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite existing Zarr groups. Default is False.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_bioformats2raw(chunks)","title":"<code>chunks</code>","text":"(<code>tuple[int, ...] | 'auto' | None</code>, default:                   <code>'auto'</code> )           \u2013            <p>Chunk shape for all arrays. See <code>write_image</code> for details.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_bioformats2raw(shards)","title":"<code>shards</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Shard shape for Zarr v3 sharding. Default is None (no sharding). When present, shard_shape must be divisible by chunk shape.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_bioformats2raw(compression)","title":"<code>compression</code>","text":"(<code>'blosc-zstd' | 'blosc-lz4' | 'zstd' | 'none'</code>, default:                   <code>'blosc-zstd'</code> )           \u2013            <p>Compression codec. Default is \"blosc-zstd\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_bioformats2raw(progress)","title":"<code>progress</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Show progress bar when writing dask arrays. Default is False.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_image","title":"write_image","text":"<pre><code>write_image(\n    dest: str | PathLike,\n    image: Image,\n    datasets: ArrayOrPyramid,\n    *,\n    labels: Mapping[str, tuple[LabelImage, ArrayOrPyramid]]\n    | None = None,\n    writer: ZarrWriter = \"auto\",\n    overwrite: bool = False,\n    chunks: tuple[int, ...]\n    | Literal[\"auto\"]\n    | None = \"auto\",\n    shards: tuple[int, ...] | None = None,\n    compression: CompressionName = \"blosc-zstd\",\n    progress: bool = False,\n) -&gt; Path\n</code></pre> <p>Write an OME-Zarr v0.5 Image group with data.</p> <p>This is the high-level function for writing a complete OME-Zarr image. It creates the Zarr group hierarchy, writes metadata, and stores data in a single call.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Path to the created Zarr group.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>If the Image model has multiple multiscales (not yet supported).</p> </li> <li> <code>ValueError</code>             \u2013            <p>If the number of datasets doesn't match the metadata.</p> </li> <li> <code>FileExistsError</code>             \u2013            <p>If <code>dest</code> exists and <code>overwrite</code> is False.</p> </li> <li> <code>ImportError</code>             \u2013            <p>If no suitable writer backend is installed.</p> </li> </ul> <p>Examples:</p> <p>Write a simple 3D image (CYX) - single dataset:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from yaozarrs import v05\n&gt;&gt;&gt; from yaozarrs.write.v05 import write_image\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = np.zeros((2, 64, 64), dtype=np.uint16)\n&gt;&gt;&gt; image = v05.Image(\n...     multiscales=[\n...         v05.Multiscale(\n...             axes=[\n...                 v05.ChannelAxis(name=\"c\"),\n...                 v05.SpaceAxis(name=\"y\", unit=\"micrometer\"),\n...                 v05.SpaceAxis(name=\"x\", unit=\"micrometer\"),\n...             ],\n...             datasets=[\n...                 v05.Dataset(\n...                     path=\"0\",\n...                     coordinateTransformations=[\n...                         v05.ScaleTransformation(scale=[1.0, 0.5, 0.5])\n...                     ],\n...                 )\n...             ],\n...         )\n...     ]\n... )\n&gt;&gt;&gt; result = write_image(\"example.ome.zarr\", image, data)\n&gt;&gt;&gt; assert result.exists()\n</code></pre> <p>Write a 3D image (CYX) with associated labels:</p> <pre><code>&gt;&gt;&gt; # Create label images for segmentation\n&gt;&gt;&gt; cells_label = v05.LabelImage(\n...     **image.model_dump(),\n...     image_label={\"colors\": [{\"label_value\": 1, \"rgba\": [255, 0, 0, 255]}]},\n... )\n&gt;&gt;&gt; cells_data = np.zeros((2, 64, 64), dtype=np.uint8)\n&gt;&gt;&gt; nuclei_label = v05.LabelImage(**image.model_dump(), image_label={})\n&gt;&gt;&gt; nuclei_data = np.zeros((2, 64, 64), dtype=np.uint8)\n&gt;&gt;&gt; result = write_image(\n...     \"example.ome.zarr\",\n...     image,\n...     data,\n...     labels={\n...         \"cells\": (cells_label, cells_data),\n...         \"nuclei\": (nuclei_label, nuclei_data),\n...     },\n...     overwrite=True,\n... )\n&gt;&gt;&gt; assert (result / \"labels\" / \"cells\" / \"0\" / \"zarr.json\").exists()\n</code></pre> See Also <p>prepare_image : Create arrays without writing data (for custom write logic). write_bioformats2raw : Write multi-series bioformats2raw layout.</p> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def write_image(\n    dest: str | PathLike,\n    image: Image,\n    datasets: ArrayOrPyramid,\n    *,\n    labels: Mapping[str, tuple[LabelImage, ArrayOrPyramid]] | None = None,\n    writer: ZarrWriter = \"auto\",\n    overwrite: bool = False,\n    chunks: tuple[int, ...] | Literal[\"auto\"] | None = \"auto\",\n    shards: tuple[int, ...] | None = None,\n    compression: CompressionName = \"blosc-zstd\",\n    progress: bool = False,\n) -&gt; Path:\n    \"\"\"Write an OME-Zarr v0.5 Image group with data.\n\n    This is the high-level function for writing a complete OME-Zarr image.\n    It creates the Zarr group hierarchy, writes metadata, and stores data\n    in a single call.\n\n    Parameters\n    ----------\n    dest : str | PathLike\n        Destination path for the Zarr group. Will be created if it doesn't exist.\n    image : Image\n        OME-Zarr Image metadata model. Must have exactly one multiscale, with\n        one Dataset entry per array in `datasets`.\n    datasets : ArrayOrPyramid\n        Data array(s) to write (numpy, dask, or any array with shape/dtype).\n        - For a single dataset, pass the array directly:\n          `write_image(dest, image, data)`\n        - For multiple datasets (e.g., multiscale pyramid), pass a sequence:\n          `write_image(dest, image, [data0, data1, ...])`\n        Must match the number and order of `image.multiscales[0].datasets`.\n    labels : Mapping[str, tuple[LabelImage, ArrayOrPyramid]] | None, optional\n        Optional label images to write alongside the image. Keys are label names\n        (e.g., \"cells\", \"nuclei\"), values are (LabelImage, datasets) tuples.\n        Labels will be written to `dest/labels/{name}/`. Default is None.\n    writer : \"zarr\" | \"tensorstore\" | \"auto\" | CreateArrayFunc, optional\n        Backend to use for writing arrays. \"auto\" prefers tensorstore if\n        available, otherwise falls back to zarr-python. Pass a custom function\n        matching the `CreateArrayFunc` protocol for custom backends.\n    overwrite : bool, optional\n        If True, overwrite existing Zarr group at `dest`. Default is False.\n    chunks : tuple[int, ...] | \"auto\" | None, optional\n        Chunk shape for storage. \"auto\" (default) calculates ~4MB chunks with\n        non-spatial dims set to 1. None uses the full array shape (single chunk).\n        Tuple values are clamped to the array shape.\n    shards : tuple[int, ...] | None, optional\n        Shard shape for Zarr v3 sharding. Default is None (no sharding).\n        When present, shard_shape must be divisible by chunk shape.\n    compression : \"blosc-zstd\" | \"blosc-lz4\" | \"zstd\" | \"none\", optional\n        Compression codec. \"blosc-zstd\" (default) provides good compression with\n        shuffle filter. \"zstd\" uses raw zstd without blosc container.\n    progress : bool, optional\n        Show progress bar when writing dask arrays. Default is False.\n\n\n    Returns\n    -------\n    Path\n        Path to the created Zarr group.\n\n    Raises\n    ------\n    NotImplementedError\n        If the Image model has multiple multiscales (not yet supported).\n    ValueError\n        If the number of datasets doesn't match the metadata.\n    FileExistsError\n        If `dest` exists and `overwrite` is False.\n    ImportError\n        If no suitable writer backend is installed.\n\n    Examples\n    --------\n    Write a simple 3D image (CYX) - single dataset:\n\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from yaozarrs import v05\n    &gt;&gt;&gt; from yaozarrs.write.v05 import write_image\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; data = np.zeros((2, 64, 64), dtype=np.uint16)\n    &gt;&gt;&gt; image = v05.Image(\n    ...     multiscales=[\n    ...         v05.Multiscale(\n    ...             axes=[\n    ...                 v05.ChannelAxis(name=\"c\"),\n    ...                 v05.SpaceAxis(name=\"y\", unit=\"micrometer\"),\n    ...                 v05.SpaceAxis(name=\"x\", unit=\"micrometer\"),\n    ...             ],\n    ...             datasets=[\n    ...                 v05.Dataset(\n    ...                     path=\"0\",\n    ...                     coordinateTransformations=[\n    ...                         v05.ScaleTransformation(scale=[1.0, 0.5, 0.5])\n    ...                     ],\n    ...                 )\n    ...             ],\n    ...         )\n    ...     ]\n    ... )\n    &gt;&gt;&gt; result = write_image(\"example.ome.zarr\", image, data)\n    &gt;&gt;&gt; assert result.exists()\n\n    Write a 3D image (CYX) with associated labels:\n\n    &gt;&gt;&gt; # Create label images for segmentation\n    &gt;&gt;&gt; cells_label = v05.LabelImage(\n    ...     **image.model_dump(),\n    ...     image_label={\"colors\": [{\"label_value\": 1, \"rgba\": [255, 0, 0, 255]}]},\n    ... )\n    &gt;&gt;&gt; cells_data = np.zeros((2, 64, 64), dtype=np.uint8)\n    &gt;&gt;&gt; nuclei_label = v05.LabelImage(**image.model_dump(), image_label={})\n    &gt;&gt;&gt; nuclei_data = np.zeros((2, 64, 64), dtype=np.uint8)\n    &gt;&gt;&gt; result = write_image(\n    ...     \"example.ome.zarr\",\n    ...     image,\n    ...     data,\n    ...     labels={\n    ...         \"cells\": (cells_label, cells_data),\n    ...         \"nuclei\": (nuclei_label, nuclei_data),\n    ...     },\n    ...     overwrite=True,\n    ... )\n    &gt;&gt;&gt; assert (result / \"labels\" / \"cells\" / \"0\" / \"zarr.json\").exists()\n\n    See Also\n    --------\n    prepare_image : Create arrays without writing data (for custom write logic).\n    write_bioformats2raw : Write multi-series bioformats2raw layout.\n    \"\"\"\n    multiscale, datasets_seq = _validate_and_normalize_datasets(image, datasets)\n\n    # Extract specs from arrays for prepare_image\n    specs: list[ShapeAndDType] = [(arr.shape, arr.dtype) for arr in datasets_seq]\n\n    # Create arrays using prepare_image\n    dest_path, arrays = prepare_image(\n        dest,\n        image,\n        specs,\n        chunks=chunks,\n        shards=shards,\n        writer=writer,\n        overwrite=overwrite,\n        compression=compression,\n    )\n\n    # Write data to arrays\n    for data_array, dataset_meta in zip(datasets_seq, multiscale.datasets):\n        _write_to_array(arrays[dataset_meta.path], data_array, progress=progress)\n\n    # Write labels if provided\n    if labels:\n        labels_builder = LabelsBuilder(\n            dest_path / \"labels\",\n            writer=writer,\n            chunks=chunks,\n            shards=shards,\n            overwrite=overwrite,\n            compression=compression,\n        )\n        for label_name, (label_image, label_datasets) in labels.items():\n            labels_builder.write_label(\n                label_name, label_image, label_datasets, progress=progress\n            )\n\n    return dest_path\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_image(dest)","title":"<code>dest</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>Destination path for the Zarr group. Will be created if it doesn't exist.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_image(image)","title":"<code>image</code>","text":"(<code>Image</code>)           \u2013            <p>OME-Zarr Image metadata model. Must have exactly one multiscale, with one Dataset entry per array in <code>datasets</code>.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_image(datasets)","title":"<code>datasets</code>","text":"(<code>ArrayOrPyramid</code>)           \u2013            <p>Data array(s) to write (numpy, dask, or any array with shape/dtype). - For a single dataset, pass the array directly:   <code>write_image(dest, image, data)</code> - For multiple datasets (e.g., multiscale pyramid), pass a sequence:   <code>write_image(dest, image, [data0, data1, ...])</code> Must match the number and order of <code>image.multiscales[0].datasets</code>.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_image(labels)","title":"<code>labels</code>","text":"(<code>Mapping[str, tuple[LabelImage, ArrayOrPyramid]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional label images to write alongside the image. Keys are label names (e.g., \"cells\", \"nuclei\"), values are (LabelImage, datasets) tuples. Labels will be written to <code>dest/labels/{name}/</code>. Default is None.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_image(writer)","title":"<code>writer</code>","text":"(<code>'zarr' | 'tensorstore' | 'auto' | CreateArrayFunc</code>, default:                   <code>'auto'</code> )           \u2013            <p>Backend to use for writing arrays. \"auto\" prefers tensorstore if available, otherwise falls back to zarr-python. Pass a custom function matching the <code>CreateArrayFunc</code> protocol for custom backends.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_image(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite existing Zarr group at <code>dest</code>. Default is False.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_image(chunks)","title":"<code>chunks</code>","text":"(<code>tuple[int, ...] | 'auto' | None</code>, default:                   <code>'auto'</code> )           \u2013            <p>Chunk shape for storage. \"auto\" (default) calculates ~4MB chunks with non-spatial dims set to 1. None uses the full array shape (single chunk). Tuple values are clamped to the array shape.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_image(shards)","title":"<code>shards</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Shard shape for Zarr v3 sharding. Default is None (no sharding). When present, shard_shape must be divisible by chunk shape.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_image(compression)","title":"<code>compression</code>","text":"(<code>'blosc-zstd' | 'blosc-lz4' | 'zstd' | 'none'</code>, default:                   <code>'blosc-zstd'</code> )           \u2013            <p>Compression codec. \"blosc-zstd\" (default) provides good compression with shuffle filter. \"zstd\" uses raw zstd without blosc container.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_image(progress)","title":"<code>progress</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Show progress bar when writing dask arrays. Default is False.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_plate","title":"write_plate","text":"<pre><code>write_plate(\n    dest: str | PathLike,\n    images: Mapping[\n        tuple[str, str, str], ImageWithDatasets\n    ],\n    *,\n    plate: Plate | dict[str, Any] | None = None,\n    writer: ZarrWriter = \"auto\",\n    overwrite: bool = False,\n    chunks: tuple[int, ...]\n    | Literal[\"auto\"]\n    | None = \"auto\",\n    shards: tuple[int, ...] | None = None,\n    compression: CompressionName = \"blosc-zstd\",\n    progress: bool = False,\n) -&gt; Path\n</code></pre> <p>Write an OME-Zarr v0.5 Plate group with data.</p> <p>This is the high-level function for writing a complete OME-Zarr plate. It creates the plate hierarchy (plate/wells/fields), writes metadata, and stores image data in a single call.</p> <p>The plate structure::</p> <pre><code>dest/\n\u251c\u2500\u2500 zarr.json          # Plate metadata\n\u251c\u2500\u2500 A/\n\u2502   \u251c\u2500\u2500 1/\n\u2502   \u2502   \u251c\u2500\u2500 zarr.json  # Well metadata (auto-generated)\n\u2502   \u2502   \u251c\u2500\u2500 0/         # Field 0\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 zarr.json  # Image metadata\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 0/     # dataset arrays\n\u2502   \u2502   \u2514\u2500\u2500 1/         # Field 1 (if multiple fields)\n\u2502   \u2514\u2500\u2500 2/\n\u2514\u2500\u2500 B/\n    \u2514\u2500\u2500 ...\n</code></pre> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Path</code>           \u2013            <p>Path to the created Plate Zarr group.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If image keys don't match plate wells, or if datasets don't match metadata.</p> </li> <li> <code>FileExistsError</code>             \u2013            <p>If <code>dest</code> exists and <code>overwrite</code> is False.</p> </li> <li> <code>ImportError</code>             \u2013            <p>If no suitable writer backend is installed.</p> </li> </ul> <p>Examples:</p> <p>Write a simple 2x2 plate with auto-generated metadata:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from yaozarrs import v05\n&gt;&gt;&gt; from yaozarrs.write.v05 import write_plate\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create image metadata (same for all fields)\n&gt;&gt;&gt; def make_image():\n...     return v05.Image(\n...         multiscales=[\n...             v05.Multiscale(\n...                 axes=[\n...                     v05.SpaceAxis(name=\"y\", unit=\"micrometer\"),\n...                     v05.SpaceAxis(name=\"x\", unit=\"micrometer\"),\n...                 ],\n...                 datasets=[\n...                     v05.Dataset(\n...                         path=\"0\",\n...                         coordinateTransformations=[\n...                             v05.ScaleTransformation(scale=[0.5, 0.5])\n...                         ],\n...                     )\n...                 ],\n...             )\n...         ]\n...     )\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Rows, columns, and wells are auto-generated from the images dict!\n&gt;&gt;&gt; images = {\n...     (\"A\", \"1\", \"0\"): (make_image(), [np.zeros((64, 64), dtype=np.uint16)]),\n...     (\"A\", \"2\", \"0\"): (make_image(), [np.zeros((64, 64), dtype=np.uint16)]),\n...     (\"B\", \"1\", \"0\"): (make_image(), [np.zeros((64, 64), dtype=np.uint16)]),\n...     (\"B\", \"2\", \"0\"): (make_image(), [np.zeros((64, 64), dtype=np.uint16)]),\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = write_plate(\"my_plate1.ome.zarr\", images)\n&gt;&gt;&gt; assert (result / \"A\" / \"1\" / \"0\" / \"zarr.json\").exists()\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Or add custom metadata like a name\n&gt;&gt;&gt; result2 = write_plate(\n...     \"my_plate2.ome.zarr\",\n...     images,\n...     plate={\"name\": \"My Experiment\"},\n...     overwrite=True,\n... )\n</code></pre> See Also <p>PlateBuilder : Builder class for incremental well/field writing. write_image : Write a single Image group.</p> Source code in <code>src/yaozarrs/write/v05/_write.py</code> <pre><code>def write_plate(\n    dest: str | PathLike,\n    images: Mapping[tuple[str, str, str], ImageWithDatasets],\n    *,\n    plate: Plate | dict[str, Any] | None = None,\n    writer: ZarrWriter = \"auto\",\n    overwrite: bool = False,\n    chunks: tuple[int, ...] | Literal[\"auto\"] | None = \"auto\",\n    shards: tuple[int, ...] | None = None,\n    compression: CompressionName = \"blosc-zstd\",\n    progress: bool = False,\n) -&gt; Path:\n    \"\"\"Write an OME-Zarr v0.5 Plate group with data.\n\n    This is the high-level function for writing a complete OME-Zarr plate.\n    It creates the plate hierarchy (plate/wells/fields), writes metadata,\n    and stores image data in a single call.\n\n    The plate structure::\n\n        dest/\n        \u251c\u2500\u2500 zarr.json          # Plate metadata\n        \u251c\u2500\u2500 A/\n        \u2502   \u251c\u2500\u2500 1/\n        \u2502   \u2502   \u251c\u2500\u2500 zarr.json  # Well metadata (auto-generated)\n        \u2502   \u2502   \u251c\u2500\u2500 0/         # Field 0\n        \u2502   \u2502   \u2502   \u251c\u2500\u2500 zarr.json  # Image metadata\n        \u2502   \u2502   \u2502   \u2514\u2500\u2500 0/     # dataset arrays\n        \u2502   \u2502   \u2514\u2500\u2500 1/         # Field 1 (if multiple fields)\n        \u2502   \u2514\u2500\u2500 2/\n        \u2514\u2500\u2500 B/\n            \u2514\u2500\u2500 ...\n\n    Parameters\n    ----------\n    dest : str | PathLike\n        Destination path for the Plate Zarr group.\n    images : Mapping[tuple[str, str, str], ImageWithDatasets]\n        Mapping of `{(row, col, fov) -&gt; (image_model, [datasets, ...])}`.\n        Each tuple key specifies (row_name, column_name, field_of_view) like\n        (\"A\", \"1\", \"0\"). Row and column names are auto-extracted from the keys.\n    plate : Plate | dict[str, Any] | None, optional\n        Optional plate metadata. Can be:\n        - None (default): Auto-generate from images dict keys\n        - dict: Merge with auto-generated metadata (user values take precedence)\n        - Plate: Use as-is (must match images dict)\n        Common dict keys: 'name', 'acquisitions', 'field_count'.\n        Auto-generated: 'rows', 'columns', 'wells'.\n    writer : \"zarr\" | \"tensorstore\" | \"auto\" | CreateArrayFunc, optional\n        Backend to use for writing arrays. Default is \"auto\".\n    overwrite : bool, optional\n        If True, overwrite existing Zarr groups. Default is False.\n    chunks : tuple[int, ...] | \"auto\" | None, optional\n        Chunk shape for all arrays. See `write_image` for details.\n    shards : tuple[int, ...] | None, optional\n        Shard shape for Zarr v3 sharding. Default is None (no sharding).\n        When present, shard_shape must be divisible by chunk shape.\n    compression : \"blosc-zstd\" | \"blosc-lz4\" | \"zstd\" | \"none\", optional\n        Compression codec. Default is \"blosc-zstd\".\n    progress : bool, optional\n        Show progress bar when writing dask arrays. Default is False.\n\n    Returns\n    -------\n    Path\n        Path to the created Plate Zarr group.\n\n    Raises\n    ------\n    ValueError\n        If image keys don't match plate wells, or if datasets don't match metadata.\n    FileExistsError\n        If `dest` exists and `overwrite` is False.\n    ImportError\n        If no suitable writer backend is installed.\n\n    Examples\n    --------\n    Write a simple 2x2 plate with auto-generated metadata:\n\n    &gt;&gt;&gt; import numpy as np\n    &gt;&gt;&gt; from yaozarrs import v05\n    &gt;&gt;&gt; from yaozarrs.write.v05 import write_plate\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Create image metadata (same for all fields)\n    &gt;&gt;&gt; def make_image():\n    ...     return v05.Image(\n    ...         multiscales=[\n    ...             v05.Multiscale(\n    ...                 axes=[\n    ...                     v05.SpaceAxis(name=\"y\", unit=\"micrometer\"),\n    ...                     v05.SpaceAxis(name=\"x\", unit=\"micrometer\"),\n    ...                 ],\n    ...                 datasets=[\n    ...                     v05.Dataset(\n    ...                         path=\"0\",\n    ...                         coordinateTransformations=[\n    ...                             v05.ScaleTransformation(scale=[0.5, 0.5])\n    ...                         ],\n    ...                     )\n    ...                 ],\n    ...             )\n    ...         ]\n    ...     )\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Rows, columns, and wells are auto-generated from the images dict!\n    &gt;&gt;&gt; images = {\n    ...     (\"A\", \"1\", \"0\"): (make_image(), [np.zeros((64, 64), dtype=np.uint16)]),\n    ...     (\"A\", \"2\", \"0\"): (make_image(), [np.zeros((64, 64), dtype=np.uint16)]),\n    ...     (\"B\", \"1\", \"0\"): (make_image(), [np.zeros((64, 64), dtype=np.uint16)]),\n    ...     (\"B\", \"2\", \"0\"): (make_image(), [np.zeros((64, 64), dtype=np.uint16)]),\n    ... }\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; result = write_plate(\"my_plate1.ome.zarr\", images)\n    &gt;&gt;&gt; assert (result / \"A\" / \"1\" / \"0\" / \"zarr.json\").exists()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Or add custom metadata like a name\n    &gt;&gt;&gt; result2 = write_plate(\n    ...     \"my_plate2.ome.zarr\",\n    ...     images,\n    ...     plate={\"name\": \"My Experiment\"},\n    ...     overwrite=True,\n    ... )\n\n    See Also\n    --------\n    PlateBuilder : Builder class for incremental well/field writing.\n    write_image : Write a single Image group.\n    \"\"\"\n    # Merge user-provided plate metadata with auto-generated\n    plate_obj = _merge_plate_metadata(images, plate)\n\n    # Use PlateBuilder to handle the writing\n    builder = PlateBuilder(\n        dest,\n        plate=plate_obj,\n        writer=writer,\n        chunks=chunks,\n        shards=shards,\n        overwrite=overwrite,\n        compression=compression,\n    )\n\n    # Group images by well: {(row, col): {fov: (Image, datasets)}}\n    wells_data: dict[tuple[str, str], dict[str, ImageWithDatasets]] = {}\n    for (row, col, fov), image_data in images.items():\n        wells_data.setdefault((row, col), {})[fov] = image_data\n\n    # Write each well with all its fields\n    for (row, col), fields_data in wells_data.items():\n        builder.write_well(row=row, col=col, images=fields_data, progress=progress)\n\n    return builder.root_path\n</code></pre>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_plate(dest)","title":"<code>dest</code>","text":"(<code>str | PathLike</code>)           \u2013            <p>Destination path for the Plate Zarr group.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_plate(images)","title":"<code>images</code>","text":"(<code>Mapping[tuple[str, str, str], ImageWithDatasets]</code>)           \u2013            <p>Mapping of <code>{(row, col, fov) -&gt; (image_model, [datasets, ...])}</code>. Each tuple key specifies (row_name, column_name, field_of_view) like (\"A\", \"1\", \"0\"). Row and column names are auto-extracted from the keys.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_plate(plate)","title":"<code>plate</code>","text":"(<code>Plate | dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional plate metadata. Can be: - None (default): Auto-generate from images dict keys - dict: Merge with auto-generated metadata (user values take precedence) - Plate: Use as-is (must match images dict) Common dict keys: 'name', 'acquisitions', 'field_count'. Auto-generated: 'rows', 'columns', 'wells'.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_plate(writer)","title":"<code>writer</code>","text":"(<code>'zarr' | 'tensorstore' | 'auto' | CreateArrayFunc</code>, default:                   <code>'auto'</code> )           \u2013            <p>Backend to use for writing arrays. Default is \"auto\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_plate(overwrite)","title":"<code>overwrite</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, overwrite existing Zarr groups. Default is False.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_plate(chunks)","title":"<code>chunks</code>","text":"(<code>tuple[int, ...] | 'auto' | None</code>, default:                   <code>'auto'</code> )           \u2013            <p>Chunk shape for all arrays. See <code>write_image</code> for details.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_plate(shards)","title":"<code>shards</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>Shard shape for Zarr v3 sharding. Default is None (no sharding). When present, shard_shape must be divisible by chunk shape.</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_plate(compression)","title":"<code>compression</code>","text":"(<code>'blosc-zstd' | 'blosc-lz4' | 'zstd' | 'none'</code>, default:                   <code>'blosc-zstd'</code> )           \u2013            <p>Compression codec. Default is \"blosc-zstd\".</p>"},{"location":"reference/yaozarrs/write/v05/#yaozarrs.write.v05.write_plate(progress)","title":"<code>progress</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Show progress bar when writing dask arrays. Default is False.</p>"}]}